<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>BigDataScript</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- Styles -->
	<link href="css/bootstrap.css" rel="stylesheet">
	<link href="css/docs.css" rel="stylesheet">
	<link href="js/google-code-prettify/prettify.css" rel="stylesheet">

	<!-- Custom styles for this template -->
	<link href="css/jumbotron.css" rel="stylesheet">
	<link href="css/my.css" rel="stylesheet">

	<!-- hTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	<script src="js/html5shiv.js"></script>
	<![endif]-->

	<!-- Fav and touch icons -->
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
	<link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
	<link rel="shortcut icon" href="ico/favicon.png">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66353152-1', 'auto');
  ga('send', 'pageview');

</script>
</head>

<body>
	<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

<!-- NAVBAR
================================================== -->
<header class="navbar navbar-static-top bs-docs-nav" id="top" role="banner">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="http://pcingola.github.com/BigDataScript/">BigDataScript</a>
		</div>
		<nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
			<ul class="nav navbar-nav">
				<li><a href="index.html">Home</a></li>
				<li><a href="download.html">Download</a></li>
				<li><a href="https://github.com/pcingola/BigDataScript">Source</a></li>
				<li class="active"><a href="bigDataScript_manual.html">Documentation</a></li>
				<li><a href="about.html">About</a></li>				
			</ul>
		</nav>
	</div>
</header>

<!-- Subhead
================================================== -->
<div class="bs-docs-header" id="content">
	<div class="container">
		<h1 class="page-header" id="">BigDataScript</h1>
		<p>Documentation</p>
	</div>
</div>

<!-- Sections
================================================== -->
<div class="container bs-docs-container">
	<div class="row">
		<div class="col-md-9" role="main">

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="install">Download &amp; Install</h1>
				<p class="lead"> Please take a look at the <a href="download.html">download page</a>.  </p>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="intro">Introduction</h1>
				<p class="lead"> BigDataScript is intended as a scripting language for big data pipeline.  </p>
				<h3>What?</h3>
				<p> BigDataScript is a cross-system scripting language for working with big data pipelines in computer systems of different sizes and capabilities.  </p>
				<h3>Why?</h3>
				Working with heavyweight computation and big data pipelines involves making use of several specialized programs. 
				Those specialized routines need to be scheduled, called and coordinated; their progress need to be tracked and their results logged. 
				That is the job of another script or program. This is when BigDataScript becomes extremely handy.
				<br>
				<br>
				Developing traditional shell scripts or small programs to coordinate data pipelines presents a fundamental dilemma. 
				It is not cross-platform, it simply does not work on all environments or it needs adaptations and re-work for the same thing to work on a laptop, server, server farm, cluster and cloud. 
				Often it is simply not possible. 
				Because of that, developing big data pipelines for a different environment is time consuming. 
				The behaviour on the target environment cannot be assumed to be an exact extrapolation of the results obtained on the development environment. 
				This not only is a waste of time, money and energy, it is also reliable source of frustration.
				<br>
				<br>
				BigDataScript is the solution to the problem.
				<br>
				<br>
				With BigDataScript, creating jobs for big data is as easy as creating a shell script and it runs seamlessly on any computer system, no matter how small or big it is. 
				If you normally use specialized programs to perform heavyweight computations, then BigDataScript is the glue to those commands you need to create a reliable pipeline.
				<h3>How?</h3>

				<p class="lead"> <b> Benefits of BigDataScript </b> </p>
				<ul>
					<li> <b>Reduced development time</b> 
					<p>
					Spend less time debugging your work on big systems with a huge data volumes. 
					Now you can debug the same jobs using a smaller sample on your computer. 
					Get immediate feedback, debug, fix and deploy when it's done. 
					Shorter development cycles means better software.
					</p>

					<li> <b>System independent</b> 
					<p>
					Cross-system, seamless execution, the same program runs on a laptop, server, server farm, cluster or cloud. 
					No changes to the program required. 
					Work once.
					</p>

					<li> <b>Easy to learn</b> 
					<p>
					The syntax is intuitive and it resembles the syntax of most commonly used programming languages. 
					Reading the code is easy as pi.
					</p>

					<li> <b>Automatic Checkpointing</b> 
					<p>
					If any task fails to execute, BigDataScript creates a checkpoint file, serializing all the information from the program. 
					Want to restart were it stopped? 
					No problem, just resume the execution from the checkpoint.
					</p>

					<li> <b>Automatic logging</b> 
					<p>
					Everything is logged (<code>-log</code> command line option), no explicit actions required. 
					Every time you execute a system command or a task, BigDataScript logs the executed commands, stdout &amp; stderr and exit codes.
					</p>

					<li> <b>Clean stop with no mess behind</b> 
					<p>
					You have a BigDataScript running on a terminal and suddenly you realized there is something wrong... 
					Just hit Ctrl-C. 
					All scheduled tasks and running jobs will be terminated, removed from the queue, deallocated from the cluster. 
					A clean stop allows you to focus on the problem at hand without having to worry about restoring a clean state.
					</p>

					<li> <b>Task dependencies</b> 
					<p>
					In complex pipelines, tasks usually depend on each other. 
					BigDataScript provides ways to easily manage task dependencies.
					</p>

					<li> <b>Avoid re-work</b> 
					<p>
					Executing the pipeline over and over should not re-do jobs that were completed successfully and moreover are time consuming. 
					Task dependency based on timestamps is a built-in functionality, thus making it easy to avoid starting from scratch every time.
					</p>

					<li> <b>Built in debugger</b> 
					<p>
					Debugging is an integral part of programming, so it is part of <code>bds</code> language.
					Statements <code>breakpoint</code> and <code>debug</code> make debugging part of the language, instead of requiring platform specific tools.
					</p>

					<li> <b>Built in test cases facility</b> 
					<p>
					Code testing is performed in everyday programming, so testing is built in <code>bds</code>.
					</p>
				</ul>

				<h3> Paper & Citations </h3>
				<p>
				If you are using BigDataScript in an academic environment, please cite our <a href="https://doi.org/10.1093/bioinformatics/btu595">paper</a>:
<pre>
BigDataScript: A scripting language for data pipelines 
P. Cingolani; R. Sladek; M. Blanchette
Bioinformatics 2014;
doi: 10.1093/bioinformatics/btu595
</pre>
				</p>

				<h3> A word about performance</h3>
				<p>
				BigDataScript is meant to be used in the context or heavyweight computations.
				Potential delays incurred by BigDataScript should not affect the overall time.
				<br>
				Think about it this way: If you are invoking a set of programs to perform big data computations, these programs usually take hours or days to run.
				The fact that BigDataScript takes a few milliseconds more to invoke those programs, really doesn't make any difference.
				</p>

				<h3> Why is it called "BigDataScript" </h3>
				Because that's the lamest name I could find.

				<h3> Disclaimer </h3>
				BigDataScript is experimental and under heavy development. Use at your own risk.
				Know side effect include: computer explosions, instant decapitation, spontaneous human combustion, and dead kittens.
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="hello">Hello world </h1>
				<p class="lead"> As we all know, showing that we can print "Hello world" is more important than showing that the language is Turing complete.  <p>
					
				<ul>
					<li> Create a simple program and execute it
					<br> File <a href="bds/test_01.bds">test_01.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

print "Hello world\n"
</pre>

<pre class="prettyprint">
$ ./test_01.bds 
Hello world
</pre>

					<li> This time we do it by running a system command (<code> echo </code>), using bds' <code>sys</code> expression. 
					A <code>sys</code> executes the command immediately in the local computer and waits until the command finishes.
					Everything after <code>sys</code> until the end of the line is interpreted as an OS command.
					<br> File <a href="bds/test_02.bds">test_02.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

sys echo Hello world
</pre>

<pre class="prettyprint">
$ ./test_02.bds 
Hello world
</pre>

					<li> Now let's run the same in as a 'task'. Tasks schedule the system command for execution (either locally, on a cluster, etc.)
					<br>
					<br> File <a href="bds/test_03.bds">test_03.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

task echo Hello world
</pre>

					Just run the script to execute tasks locally
<pre class="prettyprint">
$ ./test_03.bds
Hello world
</pre>

					You can also execute on a cluster, for instance, if you are on a cluster's head node, just run:
<pre class="prettyprint">
$ bds -s cluster ./test_03.bds
Hello world
</pre>
					Note that in order to execute on another architecture (cluster), we did not change the bds program, we just added a command line option.
					Programs can be executed on different computer systems of different sizes without changing the code.

				</ul>
				<br>
				<br>
				<iframe width="640" height="390" src="http://www.youtube.com/embed/WnwBIa4G-mE" frameborder="0" allowfullscreen></iframe>
				</p>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="language">Language </h1>
				<p class="lead"> Learning BigDataScript language (<code>bds</code>) is almost trivial, all the statements and expression and data types do what you expect. </p>
				<p>
				BigDataScript is really simple and you should be able to code within a few minutes.
				This section is intended as a reference, so just glance through it.
				<br>
				<br>
				<ul>
					<li> Comments: The usual statements are available
<pre class="prettyprint">
// Single line comment

# Another single line comment

/*
   Multi-line comment
*/
</pre>
					<li> Statements can be terminated either by semicolon or by a new line.
<pre class="prettyprint">
# Two statements
print "Hi\n"; print "Bye\n";

# Two statements, same as before but using lines instead of semicolon
print "Hi\n" 
print "Bye\n"
</pre>
					<li> <code> break </code>: Breaks from current loop
<pre class="prettyprint">
for( int i=0 ; i < 10 ; i++ ) {
    if( i == 5 ) break;	   // Finish when we reach 5
}
</pre>

					<li> <code> breakpoint </code>: Inserts a debugging breakpoint. I.e. when the statement is executed, <code>bds</code> switches execution to debug mode (STEP) 
<pre class="prettyprint">
breakpoint "Program execution will switch do debug mode here!\n"
</pre>

					<li> <code> continue </code>: Continue at the end of the current loop
<pre class="prettyprint">
for( int i=0 ; i < 10 ; i++ ) {
    if( i == 5 ) continue;	// Skip value 5
}
</pre>

					<li> <code> debug </code>: Show a debug message on STDERR only if <code>bds</code> is running in 'debug' mode (otherwise the statement is ignored).
<pre class="prettyprint">
debug "Show this message only if we are in debug mode!\n"
</pre>
					<li> <code>error</code> Show an error message and exit the program
<pre class="prettyprint">
if( num <= 0 )	warning "Number MUST be positive\n"
</pre>

					<li> <code> exit </code>: Exit program, optional expression calculates an exit value.
<pre class="prettyprint">
exit 1
</pre>

					<li> <code>for</code> C or Java like for statement
<pre class="prettyprint">
for( int i=0 ; i < 10 ; i++ ) print("$i\n")
</pre>
					or
<pre class="prettyprint">
for( int i=0 ; i < 10 ; i++ ) {
    print("$i\n")
}
</pre>

					<li> <code>for</code> Java like for iterator on lists
<pre class="prettyprint">
string[] mylist

// ... some code to populate the list

for( string s : mylist ) print("$s\n")
</pre>

					<li> <code>if / else</code> It does exactly what you expect
<pre class="prettyprint">
if( i < 10 )	print("Less than ten\n")
</pre>
					or
<pre class="prettyprint">
if( i < 10 ) {
    print("Less than ten\n")
} else if( i <= 20 ) {
    print("Between ten and twenty\n")
} else {
    print("More than twenty\n")
}
</pre>

					<li> <code> include </code> Include source code from another file
<pre class="prettyprint">
include "mymodule"

// ... use functions from 'mymodule.bds'
</pre>

					<li> <code> kill </code> Kill a task
<pre class="prettyprint">
kill taskId
</pre>

					<li> <code> print / println </code> Print to sdtout
<pre class="prettyprint">
print "Show this mesage without a new line at the end."
println "This one gets a new line at the end."
</pre>

					<li> <code> return </code> Return from a function. Optional expression is a return value.
<pre class="prettyprint">
// Define a function
int twice(int n) {
	return( 2 * n )
}
</pre>

					<li> <code> switch </code> Switch statements are similar to multiple <code> if / else if </code> statements
<pre class="prettyprint">
in := 'x'
out := 1

switch( in ) {
    case 'a': 
        out *= 3
        break

    case 'z'+'x':   # Note that the 'case' expressions are evaluated at run time (you can even call functions here)
        out *= 5    # Note that this falls through to "case 'b'"

    case 'b':
        out *= 7
        break

    default:        # You can define 'default' anywhere (no need to do it after 'case')
        out *= 100
}
</pre>

					<li> <code>warning</code> Show a warning message
<pre class="prettyprint">
if( num <= 0 )	warning "Number should be positive\n"
</pre>

					<li> <code>while</code> typical while iterator
<pre class="prettyprint">
while( i < 10 ) i++
</pre>

					<li> <code> type varName </code> Declare variable 'var' as type 'type'
<pre class="prettyprint">
int i      # 'i' is an 64 bit int variable
real r     # 'r' is a double-precision floating-point number
string s   # 's' is a string
</pre>
					<li> <code> type varName = expr </code> Declare variable 'var' as type 'type', evaluate expression and assign result to initialize 'var'.
<pre class="prettyprint">
int i = 42
real r = 3.1415927
string s = "Hello!"
</pre>

					<li> <code> varName := expr </code> Declare variable 'var', use type inference, evaluate expression 'expr' and assign result to initialize 'var'
<pre class="prettyprint">
i := 42
r := 3.1415927
s := "Hello!"
</pre>

					<li> <code> var = expr </code> Evaluate expression 'expr' and assign result to 'var'
<pre class="prettyprint">
i = j + 1
s = "Hello " + world
</pre>

					<li> <code> ( var1, var2, ..., varN ) = expr </code> Evaluate expression 'expr' (which must return a list) and assign results to 'var1', 'var2', etc. If the list size is less than the number of variables, variables are assigned default values (e.g. '0' for int). If the list has more values, they are ignored.
<pre class="prettyprint">
(name, value) = line.split('\t')
</pre>

					<li> Ternary operator <code> expr ? exprTrue : exprFalse</code> Evaluate 'expr', if true evaluate and return 'exprTrue', otherwise evalaute and return 'exprFalse'
<pre class="prettyprint">
sign = ( i >= 0 ? 1 : -1 )
</pre>

				</ul>
				<br>
				<br>
				Example: A simple, and useless, example:
<pre class="prettyprint">
// Define a function
int sumPositive(int n) {
    if( n <= 0 )	return 0

    int sum = 0
    for( int i=0 ; i <= n ; i++ ) sum = sum + i
    return sum
}

// Function definition in one line
int twice(int n)    return( 2 * n )

// Main
n := 5
print("The sum is : " + sumPositive( twice(n) ) + "\n" )
</pre>
					Obviously, if you run it
<pre class="prettyprint">
$ bds z.bds 
The sum is : 55
</pre>
				</p>

				<h3 class="page-header" id="taskCluster">Special purpose statements, commands and operators </h3>

				These are statements, operators, and expressions that are unique to <code>bds</code>.
				We just enumerate them here, but we explain details on what they mean and how they work in the following sections. 
				This list is intended as a reference for people that are already familiar with these concepts, so don't despair if you don't understand what they mean.
				<br>
				<br>
				<ul>
					<li> <code> &lt;- </code> Dependency operator. Return true if any left-hand side file needs to be updated with respect to any right-hand side file
<pre class="prettyprint">
# Evaluate dependency 
if( 'out.txt' <- 'in.txt' )    print("File out.txt needs to be updated\n")
</pre>
					<li> <code> checkpoint </code> Create a checkpoint. Optional expression is a file name
<pre class="prettyprint">
# Wait for all tasks to finish
checkpoint "program.chp"
</pre>
					<li> <code> dep </code> Define dependency tasks. Tasks are not scheduled for execution until <code>goal</code> decides which dependencies must be executed to satisfy an output.
<pre class="prettyprint">
# Execute bwa command (create an index of the human genome)
task bwa index hg19.fasta
</pre>
					<li> <code> par </code> Execute code in parallel
<pre class="prettyprint">
par {
    for( int i=0 ; i < 10 ; i++ ) {
        print("This is executed in parallel: $i\n")
    }
}
</pre>
					or just call a function in parallel
<pre class="prettyprint">
par doSomething(arg1, arg2)
</pre>
					<li> <code> sys </code> Execute an OS command. Execution is immediate and local (i.e. in the same computer as <code>bds</code> is running). It's intended for executing fast OS commands (not heavyweight processing).
<pre class="prettyprint">
# Execute an "ls" command
sys ls -al
</pre>
					<li> <code> task </code> Schedule an OS command for execution. Depending on the value of <code>system</code>, the execution can be local, in a cluster, remote server, etc.
<pre class="prettyprint">
# Execute bwa command (create an index of the human genome)
task bwa index hg19.fasta
</pre>
					<li> <code> wait </code> Wait for task(s) to finish. It can be one task, a list of tasks or all tasks (if no expression)
<pre class="prettyprint">
# Wait for all tasks to finish
wait

# Wait for one task to finish
wait taskId

# Wait for several tasks to finish
wait listOfTaskIDs
</pre>
				</ul>

				<h3 class="page-header" id="dataTypes">Data types </h3>
				<p class="lead"> BDS is a statically typed language that has simple data types. </p>

				The language is statically typed. 
				The intention is to avoid runtime errors.
				<br>
				<br>
				There are only a few basic types and, for the moment, <code>bds</code> doesn't offer extensible data types (structs, or classes), but this might change soon.

				<table class="table table-striped">
					<tr> <th> Type   </th> <th> Meaning </th> </tr>
					<tr> <td> string </td> <td> A string (same a Java's String) </td> </tr>
					<tr> <td> int	</td> <td> A 64 bit integer number (same a Java's long) </td> </tr>
					<tr> <td> real   </td> <td> A 64 bit IEEE 754 number (same as Java's double) </td> </tr>
					<tr> <td> bool   </td> <td> A boolean value, can be 'true' or 'false' (same as Java's boolean)</td> </tr>
					<tr> <td> Arrays, List, Stacks   </td> <td> These are all the same, just a different way to call a list of elements</td> </tr>
					<tr> <td> Maps   </td> <td> Maps are hashes (a.k.a. dictionaries that have <code>string</code> keys.</td> </tr>
				</table>

				There is no "null" element. Again, the idea is to minimize points of failure.

				
				<h3> Strings </h3>
				There are several basic methods defined for strings:

				<table class="table table-striped">
					<tr> <th>Return type</th><th> Method / Operator</th> <th> Meaning </th> </tr>
					<tr> <td> string	</td><td> s = s1 + s2							</td> <td> Concatenate strings.</td> </tr>
					<tr> <td> string	</td><td> s += s2								</td> <td> Append to  string.</td> </tr>
					<tr> <td> bool		</td><td> string.endsWith(string str)			</td> <td> True if string ends with str</td> </tr>
					<tr> <td> bool		</td><td> string.isEmpty()					   </td> <td> True if the string is empty</td> </tr>
					<tr> <td> int		</td><td> string.indexOf(string str)				</td> <td> Index of the first occurrence of str in string</td> </tr>
					<tr> <td> int		</td><td> string.lastIndexOf(string str)			</td> <td> Index of the last occurrence of str in string</td> </tr>
					<tr> <td> int		</td><td> string.length()							</td> <td> String's length </td> </tr>
					<tr> <td> string	</td><td> string.replace(string str1,string str2)	</td> <td> A new string replacing 'str1' with 'str2'</td> </tr>
					<tr> <td> bool		</td><td> string.parseBool()						</td> <td> Parse a bool </td> </tr>
					<tr> <td> int		</td><td> string.parseInt()							</td> <td> Parse an int number </td> </tr>
					<tr> <td> real		</td><td> string.parseReal()						</td> <td> Parse a real number </td> </tr>
					<tr> <td> string[]	</td><td> string.split(string regex)				</td> <td> Split using a regular expression </td> </tr>
					<tr> <td> bool		</td><td> string.startsWith(string str)			</td> <td> True if string starts with str</td> </tr>
					<tr> <td> string	</td><td> string.substr(int start)			   </td> <td> Substring from start to end of string</td> </tr>
					<tr> <td> string	</td><td> string.substr(int start,int end)	   </td> <td> Substring from start to end</td> </tr>
					<tr> <td> string	</td><td> string.toLower()						</td> <td> Return a lower case version of the string</td> </tr>
					<tr> <td> string	</td><td> string.toUpper()						</td> <td> Return an upper case version of the string</td> </tr>
					<tr> <td> string	</td><td> string.trim()							</td> <td> Trim spaces at the beginnig and at the end</td> </tr>
				</table>

				<h3> Strings as file names </h3>
				Strings can be used in several different ways.
				For instance, it is common that a string can represent a file name in a script.
				So you can use 'file' related methods on string.
				E.g.:
<pre class="prettyprint">
string f = "in.txt"
if( f.canRead() ) {
    print (" Can read file $f\n" )
}
</pre>
				Here <code>f</code> is a string, but it has a method <code>canRead()</code> which retuurns true if f is a file and it can be read.
				<br>
				<br>
# 				More file related methods:

				<table class="table table-striped">
					<tr> <th>Return type</th><th> Method</th> 								<th> Meaning </th> </tr>
					<tr><td>string		</td> <td>string.baseName()					</td> <td> File's base name	</td> </tr>
					<tr><td>string		</td> <td>string.baseName(string ext)		</td> <td> File's base name, remove extention 'ext'	</td> </tr>
					<tr><td>string		</td> <td>string.download()					</td> <td> Donwload data from URL (string). Returns local file name (empty string if failed) </td> </tr>
					<tr><td>bool		</td> <td>string.download(string file)		</td> <td> Donwload data from URL to 'file'. Returns true if succeeded. </td> </tr>
					<tr><td>bool		</td> <td>string.canRead()					</td> <td> True if file has read permission	</td> </tr>
					<tr><td>bool		</td> <td>string.canWrite()					</td> <td> True if file has write permission   </td> </tr>
					<tr><td>bool		</td> <td>string.canExec()					</td> <td> True if file has execution permission	</td> </tr>
					<tr><td>void		</td> <td>string.chdir()					</td> <td> Change current directory</td> </tr>
					<tr><td>bool		</td> <td>string.delete()					</td> <td> Delete file	</td> </tr>
					<tr><td>string[]	</td> <td>string.dir()						</td> <td> List files in a directory ('ls')   </td> </tr>
					<tr><td>string[]	</td> <td>string.dir(string regex)			</td> <td> List files matching a 'glob' (regular expression for files)</td> </tr>
					<tr><td>string		</td> <td>string.dirName()					</td> <td> File's directory name	</td> </tr>
					<tr><td>string[]	</td> <td>string.dirPath()					</td> <td> List files using canonical paths	</td> </tr>
					<tr><td>string[]	</td> <td>string.dirPath(string regex)		</td> <td> List files, matching a 'glob' (regular expression for files), using canonical paths	</td> </tr>
					<tr><td>string		</td> <td>string.extName()				  	</td> <td> File's extension	</td> </tr>
					<tr><td>bool		</td> <td>string.exists()					</td> <td> True if file exists	</td> </tr>
					<tr><td>bool		</td> <td>string.isDir()					</td> <td> True if it's a directory	</td> </tr>
					<tr><td>bool		</td> <td>string.isFile()					</td> <td> True if it's a file	</td> </tr>
					<tr><td>bool		</td> <td>string.mkdir()					</td> <td> Create dir ('mkdir -p')   </td> </tr>
					<tr><td>string		</td> <td>string.path()						</td> <td> Canonical path to file	</td> </tr>
					<tr><td>string		</td> <td>string.pathName()					</td> <td> Canonical dir to file	</td> </tr>
					<tr><td>string		</td> <td>string.read()						</td> <td> Read the whole file into a string	</td> </tr>
					<tr><td>string[]	</td> <td>string.readLines()				</td> <td> Read the whole file and split the lines	</td> </tr>
					<tr><td>string		</td> <td>string.removeExt()				</td> <td> Remove file extension </td> </tr>
					<tr><td>string		</td> <td>string.removeExt(string ext)		</td> <td> Remove file extension, only if it matches the provided one </td> </tr>
					<tr><td>bool		</td> <td>string.rm()				 		</td> <td> Delete a file </td> </tr>
					<tr><td>bool		</td> <td>string.rmExit()			 		</td> <td> Remove a file when execution finishes (thread execution).</td> </tr>
					<tr><td>int			</td> <td>string.size()						</td> <td> File size in bytes  </td> </tr>
					<tr><td>string		</td> <td>string.swapExt(string newExt)	</td> <td> Swap file extension </td> </tr>
					<tr><td>string		</td> <td>string.swapExt(string oldExt,string newExt)		</td> <td> Swap file extension, only if extension matches the provided 'oldExt'</td> </tr>
					<tr><td>string		</td> <td>string.upload()					</td> <td> Upload data to URL (string). Returns true if succeeded. </td> </tr>
					<tr><td>bool		</td> <td>string.upload(string file)		</td> <td> Upload data from 'file' to URL. Returns true if succeeded. </td> </tr>
					<tr><td>string		</td> <td>string.write(string file)			</td> <td> Write string to 'file' </td> </tr>
				</table>
				
				<h3> Strings as task IDs </h3>
				Strings can also be used to refer to tasks.
				When a task is created, the <code>task</code> expression returns a task ID, which is a string.
				This task ID can be used for task operations, for instance:
<pre class="prettyprint">
tid := task echo Hello
wait tid
</pre>
				Here the <code>wait</code> statement will wait until the task "echo Hello" finishes executing.
				<br>
				<br>
				More task related methods:
				<table class="table table-striped">
					<tr> <th>Return type</th><th> Method</th> <th> Meaning </th> </tr>
					<tr> <td> bool	</td> <td> string.isDone()   </td> <td> True if the task finished</td> </tr>
					<tr> <td> bool	</td> <td> string.isDoneOk() </td> <td> True if the task finished without errors </td> </tr>
					<tr> <td> string  </td> <td> string.stdout()   </td> <td> A string with all the STDOUT generated from this task </td> </tr>
					<tr> <td> string  </td> <td> string.stderr()   </td> <td> A string with all the STDERR generated from this task </td> </tr>
					<tr> <td> int	 </td> <td> string.exitCode() </td> <td> Exit code</td> </tr>
				</table>

				<h3> Arrays, List, Stacks </h3>
				Arrays, list and stacks are all the same thing.
				You can create a list of strings simply by declaring:
<pre class="prettyprint">
string[] arrayEmpty
string[] array = ["one", "two", "three"]
</pre>
				Similarly, a list of ints is just
<pre class="prettyprint">
int[] listIntEmpty
int[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
</pre>
				<br>
				<b> Methods </b>
				<table class="table table-striped">
					<tr> <th>Returns </th><th> Method</th> <th> Meaning </th> </tr>
					<tr> <td> </td> <td> += </td> <td> Append element(s) at the end of the list </td> </tr>
					<tr> <td> Element added  </td> <td> add(X) </td> <td> Add <code>X</code> to the end of the list </td> </tr>
					<tr> <td> Element added  </td> <td> add(int idx,X) </td> <td> Add <code>X</code> to position <code>idx</code> in the list </td> </tr>
					<tr> <td> Same list  </td> <td> delete() </td> <td> Delete all files in the list (assumes list elements are file names). Same as <code>list.rm()</code></td> </tr>
					<tr> <td> int </td> <td> count(X) </td> <td> Count number of occurrences of <code>X</code> in the list </td> </tr>
					<tr> <td> bool </td> <td> has(X) </td> <td> Does the list contain <code>X</code>? </td> </tr>
					<tr> <td> First element  </td> <td> head() </td> <td> Get first element </td> </tr>
					<tr> <td> int </td> <td> indexOf(X) </td> <td> Position of element <code>X</code> in the list </td> </tr>
					<tr> <td> bool </td> <td> isEmpty() </td> <td> 'true' if the list is empty </td> </tr>
					<tr> <td> string </td> <td> join() </td> <td> A string joining all elements of the list (separator ' ') </td> </tr>
					<tr> <td> string </td> <td> join(string sep) </td> <td> A string joining all elements of the list (separator 'sep') </td> </tr>
					<tr> <td> Last element  </td> <td> pop() </td> <td> Get last element and remove it from the list </td> </tr>
					<tr> <td> Element pushed  </td> <td> push() </td> <td> Add at the end of the list </td> </tr>
					<tr> <td> Element to remove  </td> <td> remove(X) </td> <td> Remove element <code>X</code> from the list </td> </tr>
					<tr> <td> Element to remove  </td> <td> removeIdx(int idx) </td> <td> Remove element at position <code>idx</code> from the list </td> </tr>
					<tr> <td> New reversed list </td> <td> reverse() </td> <td> Create a new list and reverse it</td> </tr>
					<tr> <td> Same list </td> <td> rm() </td> <td> Delete all files (assumes list elements are file names) </td> </tr>
					<tr> <td> Same list </td> <td> rmOnExit() </td> <td> Delete all files when current thread finishes execution (assumes list elements are file names) </td> </tr>
					<tr> <td> int </td> <td> size() </td> <td> Return the number of elements in the list </td> </tr>
					<tr> <td> New sorted list </td> <td> sort() </td> <td> Create a new list sorting the elements of this list</td> </tr>
					<tr> <td> List  </td> <td> tail() </td> <td> Create a new list with all but the first element</td> </tr>
				</table>
				<br>

				<b>Iterating on an array/list</b><br>
				You can iterate on an array simply by doing
<pre class="prettyprint">
$ cat z.bds 
string[] array = ["one", "two", "three"]

for( string val : array ) { print("Value: $val\n") }

$ bds /z.bds
Value: one
Value: two
Value: three
</pre>
				</p>

				<h3> Maps </h3>
				Maps are hashes that have <code>string</code> as keys.
				You can create a map simply by declaring:
<pre class="prettyprint">
string{} mstr	# This maps string keys to string values

mstr{"Hello"} = "Bye"
mstr{"Bonjour"} = "Au revoir"
mstr{"Hola"} = "Adios"
</pre>

				or a map of real numbers
<pre class="prettyprint">
real{} mre   # This maps string keys to real values
mre{"one"}   = 1.0
mre{"two"}   = 2.0
mre{"e"}     = 2.7182818
mre{"three"} = 3.0
mre{"pi"}    = 3.1415927
</pre>
				<br>
				<b> Methods </b>
				<table class="table table-striped">
					<tr> <th>Returns </th><th> Method</th> <th> Meaning </th> </tr>
					<tr> <td> bool </td> <td> hasKey(string key) </td> <td> True if the key is in the map </td> </tr>
					<tr> <td> bool </td> <td> hasValue(value) </td> <td> True if 'value' is in the map </td> </tr>
					<tr> <td> list </td> <td> keys() </td> <td> A sorted list of all keys in the map</td> </tr>
					<tr> <td> bool </td> <td> remove(key) </td> <td> Remove <code>key</code> from this map</td> </tr>
					<tr> <td> int </td> <td> size() </td> <td> Number of elements in this map</td> </tr>
					<tr> <td> list </td> <td> values() </td> <td> A sorted list of all values in the map</td> </tr>
				</table>
				<br>
				<b>Iterating on a map</b><br>
				You can iterate over all values in a map, simply by doing
<pre class="prettyprint">
$ cat z.bds 
string{} mstr = { "Hello" => "Bye", "Bonjour" => "Au revoir", "Hola" => "Adios" }

for(string v : mstr ) { 
		print("Values : $v\n") 
}

$ bds z.bds
Values : Adios
Values : Au revoir
Values : Bye

</pre>

				If you want to iterate on keys instead of values, you can do this:
<pre class="prettyprint">
$ cat z.bds 
string{} mstr = { "Hello" => "Bye", "Bonjour" => "Au revoir", "Hola" => "Adios" }

for(string k : mstr.keys() ) { 
		print("Key : $k\tValue : " + mstr{k} + "\n") 
}

$ bds z.bds
Key : Bonjour	Value : Au revoir
Key : Hello	Value : Bye
Key : Hola	Value : Adios
</pre>

				</p>

				<h3 class="page-header" id="vars">Predefined functions </h3>
				<p class="lead"> BigDataScript provides some predefined functions.</p>
				<br>
				<table class="table table-striped">
					<tr> <th> Function </th> <th> Meaning </th> </tr>
					<tr> <td> int abs(int x)								</td> <td> Absolute value of a number </td> </tr>
					<tr> <td> real abs(real x)								</td> <td> Absolute value of a number </td> </tr>
					<tr> <td> real acos(real x)								</td> <td> The trigonometric arc-cosine of a number </td> </tr>
					<tr> <td> real asin(real x)								</td> <td> The trigonometric arc-sine of a number </td> </tr>
					<tr> <td> real atan(real x)								</td> <td> The trigonometric arc-tangent of a number </td> </tr>
					<tr> <td> real atan2(real x)							</td> <td> Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta).</td> </tr>
					<tr> <td> assert(bool expr) 							</td> <td> Used for testing: Throw an error if <code>expr</code> is <code>false</code> </td> </tr>
					<tr> <td> assert(string msg, bool expr) 				</td> <td> Used for testing: Throw error message <code>msg</code> if <code>expr</code> is <code>false</code> </td> </tr>
					<tr> <td> assert(string msg, bool expected, bool result)</td> <td> Used for testing: Throw error message <code>msg</code> if <code>result</code> value is not equal to <code>expected</code> (compare <code>bool</code>) </td> </tr>
					<tr> <td> assert(int expected, int result)				</td> <td> Used for testing: Throw error message <code>msg</code> if <code>result</code> value is not equal to <code>expected</code> (compare <code>int</code>)</td> </tr>
					<tr> <td> assert(string msg, int expected, int result)	</td> <td> Used for testing: Throw error message if <code>result</code> value is not equal to <code>expected</code> (compare <code>int</code>)</td> </tr>
					<tr> <td> assert(string expected, string result)		</td> <td> Used for testing: Throw error message if <code>result</code> value is not equal to <code>expected</code> (compare <code>string</code>)</td> </tr>
					<tr> <td> assert(string msg, string expected, string result)</td> <td> Used for testing: Throw error message <code>msg</code> if <code>result</code> value is not equal to <code>expected</code> (compare <code>string</code>)</td> </tr>
					<tr> <td> real cbrt(real x)								</td> <td> The cube root of a number </td> </tr>
					<tr> <td> real ceil(real x)								</td> <td> The ceiling of a number </td> </tr>
					<tr> <td> string{} config(string fileName)				</td> <td> Read and parse 'fileName', return &lt;name,value&gt; pairs in a map.<br>
																					Parsing: Lines starting with '#' are ignored, so are blank lines.<br>
																					Name/Value delimiters can be any of ':', '=' or '\t' (the first one found in each line will be used).<br>
																					The following are valid and equivalent:<br>
<pre>
name : value
name = value
name \t value
</pre>
					<tr> <td> string{} config(string fileName, string{} defaults)			</td> <td> Same as <code>string{} config(string fileName)</code>, but using <code>defaults</code> as default values (if not found in fileName) </td> </tr>
					<tr> <td> real copySign(real x, real y)					</td> <td> Returns the first floating-point argument with the sign of the second floating-point argument</td> </tr>
					<tr> <td> real cos(real x)								</td> <td> The trigonometric cosine of an angle </td> </tr>
					<tr> <td> real cosh(real x)								</td> <td> The hyperbolic cosine of an angle </td> </tr>
					<tr> <td> real exp(real x)								</td> <td> Return e^x </td> </tr>
					<tr> <td> real exppm1(real x)							</td> <td> Return e^x-1 </td> </tr>
					<tr> <td> real floor(real x)							</td> <td> The floor of a number </td> </tr>
					<tr> <td> int getExponent(real x)						</td> <td> exponent used in the representation of a real</td> </tr>
					<tr> <td> real hypot(real x, real y)					</td> <td> Returns sqrt(x2 +y2) without intermediate overflow or underflow. </td> </tr>
					<tr> <td> real IEEEremainder(real x, real y)			</td> <td> Computes the remainder operation on two arguments as prescribed by the IEEE 754 standard.. </td> </tr>
					<tr> <td> log(string msg)								</td> <td> Log 'msg' (i.e. show to stderr) </td> </tr>
					<tr> <td> real log(real x)								</td> <td> Natural logarithm of a number </td> </tr>
					<tr> <td> real log10(real x)							</td> <td> Logarithm (base 10) of a number </td> </tr>
					<tr> <td> real log1p(real x)							</td> <td> Natural logarithm of '1+x' </td> </tr>
					<tr> <td> int max(int n1, int n2) 						</td> <td> Maximum of two numbers </td> </tr>
					<tr> <td> real max(real n1, real n2) 					</td> <td> Maximum of two numbers </td> </tr>
					<tr> <td> int min(int n1, int n2) 						</td> <td> Minimum of two numbers </td> </tr>
					<tr> <td> real min(real n1, real n2) 					</td> <td> Minimum of two numbers </td> </tr>
					<tr> <td> real nextAfter(real x, real y)				</td> <td> Returns the number adjacent to the first argument in the direction of the second argument</td> </tr>
					<tr> <td> real nextUp(real x)							</td> <td> Returns the floating-point value adjacent to d in the direction of positive infinity.</td> </tr>
					<tr> <td> real pow(real x, real y)						</td> <td> Return x^y </td> </tr>
					<tr> <td> print( expr )									</td> <td> Show to stdout (same as 'print' statement) </td> </tr>
					<tr> <td> printErr( expr )								</td> <td> Show to stderr </td> </tr>
					<tr> <td> printHelp()									</td> <td> Print automatically generated help message (see 'help' statement) </td> </tr>
					<tr> <td> real rand() 									</td> <td> Random number [0, 1] interval </td> </tr>
					<tr> <td> int randInt() 								</td> <td> Random number (64 bits) </td> </tr>
					<tr> <td> int randInt(int range)						</td> <td> Random number [0, range] interval </td> </tr>
					<tr> <td> void randSeed(int seed)						</td> <td> Set random seed (for current thread) </td> </tr>
					<tr> <td> int[] range(min, max)							</td> <td> A list of numbers between [min, max] inclusive </td> </tr>
					<tr> <td> int[] range(min, max, step)					</td> <td> A list of numbers between [min, min+step, min+2*step, ... ]. Includes max if min+N*step = max </td> </tr>
					<tr> <td> real[] range(min, max, step)					</td> <td> A list of numbers between [min, min+step, min+2*step, ... ]. Includes max if min+N*step = max </td> </tr>
					<tr> <td> real rint(real x) 							</td> <td> Returns the real value that is closest in value to the argument and is equal to a mathematical integer </td> </tr>
					<tr> <td> int round(real x) 							</td> <td> Rounded number </td> </tr>
					<tr> <td> real scalb(real x, int sf)					</td> <td> Return x * 2^sf rounded  </td> </tr>
					<tr> <td> real signum(real x)							</td> <td> The sign function of a number </td> </tr>
					<tr> <td> real sin(real x)								</td> <td> The trigonometric sine of an angle </td> </tr>
					<tr> <td> real sinh(real x)								</td> <td> The hyperbolic-sine of an angle </td> </tr>
					<tr> <td> sleep( int seconds )							</td> <td> Sleep for 'seconds' </td> </tr>
					<tr> <td> sleep( real seconds )							</td> <td> Sleep for '1000 * seconds' milliseconds. E.g. sleep(0.5) sleeps for half a second </td> </tr>
					<tr> <td> real sqrt(real x)								</td> <td> The square root of a number</td> </tr>
					<tr> <td> real tan(real x)								</td> <td> The trigonometric tangent of an angle </td> </tr>
					<tr> <td> real tanh(real x)								</td> <td> The hyperbolic tangent of an angle </td> </tr>
					<tr> <td> int time()									</td> <td> Return the milliseconds elapsed since epoch</td> </tr>
					<tr> <td> real toDegrees(real x)						</td> <td> Convert x radians to degrees</td> </tr>
					<tr> <td> real toRadians(real x)						</td> <td> Convert x degrees to radians</td> </tr>
					<tr> <td> int toInt(bool b)								</td> <td> Convert boolean to int </td> </tr>
					<tr> <td> int toInt(real r)								</td> <td> Convert real to int </td> </tr>
					<tr> <td> real ulp(real r)								</td> <td> Returns the size of an ulp of the argument</td> </tr>

				</table>

				<h3 class="page-header" id="vars">Predefined global variables </h3>
				<p class="lead"> BigDataScript provides some predefined variables.</p>
				<br>
				Whenever you run a BigDataScript program you have several predefined variables:
				<table class="table table-striped">
					<tr>
						<th> Variable name </th>
						<th> Meaning </th>
					</tr>
					<tr>
						<td> <code>allowEmpty</code> 
							, <code>canFail</code> 
							, <code>cpus</code>
							, <code>mem</code>
							, <code>timeout</code>
							, <code>node</code>
							, <code>queue</code>  
							, <code>retry</code>  
							, <code>system</code>  
							, <code>taskName</code>  
							, <code>timeout</code>  
							, <code>walltimeout</code>  
						</td>	
						<td> These are the default values for <code>task</code>. Their meanings are explained in the Task section of this handbook. </td> 
					</tr>
					<tr>
						<td> string <code>programName</code> </td>	
						<td> The program's name </td> 
					</tr>
					<tr>
						<td> string <code>programPath</code> </td>	
						<td> The program's path </td> 
					</tr>
					<tr>
						<td> string[] <code>args</code> </td>	
						<td> Arguments used to invoke the program, i.e. all command line options after program name (<code>bds [options] prog.bds args ...</code>). </td> 
					</tr>
					<tr>
						<td> string <code>ppwd</code> </td>	
						<td> Canonical (physical) path to directory where the program is being executed. </td> 
					</tr>
					<tr>
						<td> int <code>cpusLocal</code> </td>	
						<td> Number of cores in the computer running the script </td> 
					</tr>
					<tr>
						<td> All shell variables </td>	
						<td> All shell variables at the moment of invocation (e.g. <code>HOME</code>, <code>PWD</code>, etc.)</td> 
					</tr>
					<tr>
						<td> int <code>K, M, G, T, P</code> </td>	
						<td> Kilo, Mega, Giga, Tera, Peta (2^10, 2^20, 2^30, 2^40 and 2^50 respectively)</td> 
					</tr>
					<tr>
						<td> real <code>E, PI</code> </td>	
						<td> Euler's constant (2.718281...) and Pi (3.1415927...) </td> 
					</tr>
					<tr>
						<td> int <code>minute, hour, day, week</code> </td>	
						<td> Number of seconds in a minute, hour, day and week respectively</td> 
					</tr>
				</table>
				<br>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="task"> Creating data pipelines </h1>
				<p class="lead"> In order to create data pipelines, you need to execute 'tasks' and coordinate execution dependencies. Here we show how to do it in <code>bds</code></p>
					
				<h3 class="page-header" id="task">Executing a task </h3>
				The most basic operation is to execute a task, which is done using a <code>task</code> expression.
				<code>bds</code> takes care of executing a task on different environments (local computer, server, cluster, etc.), so you don't need to focus on mundane details (such as cluster queue monitoring, or querying remote computers for resources).
				<br>
				<br>
				In this toy example, we schedule 10 tasks for execution. 
				I'm running this on a computer that only has 8 CPUs, so not all tasks can execute in parallel.
				
				<br> File <a href="bds/test_04.bds">test_04.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

for( int i=0 ; i < 10 ; i++ ) {
	task echo Hi $i ; sleep 1 ; echo Done $i ; sleep 1
}
</pre>

Note that bds interpolates variable <code>$i</code> (string interpolation simply means replacing by the value of a variable within the string)
<br>
<br>

<pre class="prettyprint">
$ ./test_04.bds
Hi 1
Hi 6
Hi 2
Hi 4
Hi 3
Hi 7
Hi 0
Hi 5
Done 1
Done 6
Done 2
Done 4
Done 3
Done 7
Done 0
Done 5
Hi 9
Hi 8
Done 9
Done 8
</pre>

				In this case, we are running on an 8 core computer, so the first 8 tasks get executed in parallel. 
				The rest is executed when the first tasks finish.

				<i class="icon-warning-sign"></i> Task execution order is not guaranteed (e.g. a cluster scheduler can decide to run tasks out of order).
				We'll see how to coordinate tasks later.
				<br>
				<br>
				<iframe width="640" height="390" src="http://www.youtube.com/embed/ehFfU8vLwi8" frameborder="0" allowfullscreen></iframe>

				<h3 class="page-header" id="taskCluster">Running on a cluster </h3>
				Here we show how exactly the same script is run on a cluster, keep in mind that not a single line of code changed. 
				We copy tha same script (used in the previous section) to a cluster. 
				We execute it, but now the tasks are scheduled using MOAB, Torque, PBS or Grid Engine.
				<br>
				<br>
<pre class="prettyprint">
$ bds -s cluster test_04.bds
</pre>
				<br>
				<br>
				<iframe width="640" height="390" src="http://www.youtube.com/embed/o47wxUdYzvk" frameborder="0" allowfullscreen></iframe>
				</p>
					
				<h3 class="page-header" id="taskDep">Task dependencies</h3>
				<p class="lead">
				In a typical pipeline we must be able to control task execution which depends on previously executed tasks.
				Here we show how.
				<p>
					
				<h3 class="page-header" id="taskDep2">Waiting for a task to finish '<code>wait</code>' </h3>
				The simplest form of execution control is to wait until one or more tasks finish before executing the next task(s).
				This is done using the <code>wait</code> statement.
				<br>
				<br>
				In this example, we run a set of tasks (<code>echo Hi $i</code>) and after all the tasks finished, we run another set of tasks (<code>echo Bye $i</code>)
				<br> File <a href="bds/test_05.bds">test_05.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

for( int i=0 ; i < 10 ; i++ ) {
    task echo Hi $i ; sleep 1 
}

wait
print("After wait\n")

for( int i=0 ; i < 10 ; i++ ) {
    task echo Bye $i ; sleep 1
}
</pre>

				Running the script, we get
<pre class="prettyprint">
$ ./test_05.bds
Hi 7
Hi 0
Hi 6
Hi 5
Hi 1
Hi 3
Hi 4
Hi 2
Hi 8
Hi 9
After wait
Bye 1
Bye 0
Bye 7
Bye 2
Bye 6
Bye 4
Bye 3
Bye 5
Bye 9
Bye 8
</pre>
				<ul>
					<li> The <code>wait</code> statement is like a barrier. Until all tasks are finished, the program does not continue.
					If any task fails, a checkpoint file is created, where all program data is serialized.
					We can correct the problem and restart the pipeline where it left.

					<li> The <code>wait</code> statement can wait for all tasks, for single tasks or for a list of tasks.

					<li> We then run the same script on a cluster. 
					Again, this is done simply by using <code>-s cluster</code> command line.
					The video shows how tasks are scheduled and on the cluster, always honoring the <code>wait</code> statement

					<li> The exit code of a <code>bds</code> script is 0 if all tasks executed without any problems, and non-zero if any task failed.
				</ul>

				<iframe width="640" height="390" src="http://www.youtube.com/embed/vTekXn3sKzs" frameborder="0" allowfullscreen></iframe>
				</p>
					
				<h3 class="page-header" id="taskDep2">Dependency operator '<code>&lt;-</code>' </h3>
				<p class="lead">
				The dependency operator provides a simple way to see if a file needs to be updated (i.e. recalculated) with respect to some inputs.
				For instance, when we already processed some files and have the corresponding results, we may save some work if the inputs have not changed (like "make" command).
				<p>
				
				We introduce the dependency operator <code>&lt;-</code> (pronounced 'dep') which is a "make" style operator.
				The expression <code>out &lt;- in</code> is true if 'out' file needs to be updated.
				More formally, the expression is true if the file name represented by the variable 'out' does not exist, is empty (zero length) or has a creation date before 'in'.<br>
				E.g.:
				<br>
				<br> File <a href="bds/test_06.bds">test_06.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

string inFile  = "in.txt"
string outFile = "out.txt"

# Create 'in.txt' if it doesn't exist
if( !inFile.exists() ) {
    task echo Creating $inFile; echo Hello > $inFile
}

wait

# Create 'out.txt' only if needs to be updated resepct to 'in.txt'
if( outFile <- inFile ) {
    task echo Creating $outFile; cat $inFile > $outFile
}
</pre>

When executing for the first time, both tasks are executed and both files ('in.txt' and 'out.txt') are created.
<pre class="prettyprint">
$ ./test_06.bds
Creating in.txt
Creating out.txt
</pre>

If we execute for a second time, since files have not changed, no <code>task</code> is executed.
<pre class="prettyprint">
$ ./test_06.bds
$
</pre>

If we now change the contents of 'in.txt', and run the script again, the second <code>task</code> will be executed (because 'out.txt' needs to be updated with respect to 'in.txt')
<pre class="prettyprint">
# Update 'in.txt'
$ date > in.txt

# Since we updated the input file, the output must be recalculated
$ ./test_06.bds 
Creating out.txt
</pre>

					<li> Summary: If the file 'out.txt' is up to date with respect to 'in.txt', the following condition will be false and the <code>task</code> will not execute
<pre class="prettyprint">
if( outFile <- inFile ) {
	task echo Creating $outFile; cat $inFile > $outFile
}
</pre>

					<li> This construction is so common that we allow for some syntactic sugar. 
<pre class="prettyprint">
task( outFile <- inFile ) { 
	sys echo Creating $outFile; cat $inFile > $outFile
}
</pre>
				</ul>

				<br>
				<br>
				<iframe width="640" height="390" src="http://www.youtube.com/embed/oSjhkRuc0I8" frameborder="0" allowfullscreen></iframe>
				</p>

				<h3 class="page-header" id="taskDep2">Automatic task dependency detection </h3>
				<p class="lead">
				Programming task dependencies can be difficult.
				BDS can help by automatically inferring task dependencies and executing tasks in the correct order.
				<p>
				<br> In this example, we have two tasks:
				<ul>
					<li> The first task uses an input file 'in.txt', to create an intermediate file 'inter.txt' 
					<li> The second task uses the intermediate file 'inter.txt' to create the ouptut file 'out.txt'.
				</ul>
				The script below does not have a <code>wait</code> statement. 
				Instead <code>bds</code> automatically infers that the second task depends on the first one, and does not start execution until the first task begins.
				Notice that we don't tell bds to wait for the first task to finish (there is no explicit <code>wait</code> statement). 
				<br>
				<br> File <a href="bds/test_07.bds">test_07.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

# We use ':=' for declaration with type inference
inFile       := "in.txt"		
intermediate := "inter.txt"
outFile      := "out.txt"

task( intermediate <- inFile) {
    sys echo Creating $intermediate; cat $inFile > $intermediate; sleep 1 ; echo Done $intermediate
}

task( outFile <- intermediate ) {
    sys echo Creating $outFile; cat $intermediate > $outFile; echo Done $outFile
}
</pre>

				As a side note: We used the <code>:=</code> operator to declare variables using type inference. 
				So we can write <code>inFile := "in.txt"</code> instead of <code>string inFile = "in.txt"</code>, which not only is shorter to type, but also makes the code look cleaner.
				<br>
				<br>
				Now let's run the script
<pre class="prettyprint">
# Delete old file (if anY)
$ rm *.txt

# Create input file
$ date > in.txt

# Run
$ ./test_07.bds 
Creating inter.txt
Done inter.txt
Creating out.txt
Done out.txt
</pre>
				Note how the second task is executed only after the first one finished.

				<h3 class="page-header" id="taskDep2">Complex dependencies: <code>dep</code> and <code>goal</code> </h3>
				<p class="lead">
				The <code>goal</code> statement helps to program complex task scheduling interdependencies.
				<p>

				In the previous example, we had an input file 'in.txt', an intermediate file 'inter.txt' and an output file 'out.txt'.
				One problem is that if we delete the intermediate file 'inter.txt' (e.g. because we may want to delete big files with intermediate results), then both tasks will be executed

				<br>
				For convenience, here is the code again. File <a href="bds/test_07.bds">test_07.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

inFile       := "in.txt"		
intermediate := "inter.txt"
outFile      := "out.txt"

task( intermediate <- inFile) {
    sys echo Creating $intermediate; cat $inFile > $intermediate; sleep 1 ; echo Done $intermediate
}

task( outFile <- intermediate ) {
    sys echo Creating $outFile; cat $intermediate > $outFile; echo Done $outFile
}
</pre>
<pre class="prettyprint">
# Remove intermediate file
$ rm inter.txt 

# Re-execute script 
$ ./test_07.bds
Creating inter.txt
Done inter.txt
Creating out.txt
Done out.txt
</pre>

				Why is this happening? The reason is that <code>task</code> statements are evaluated in order. 
				So when <code>bds</code> evaluates the first <code>task</code> expression, the dependency <code>intermediate &lt;- inFile</code> is true (because 'inter.txt' doesn't exist, so it must be updated with respect to 'in.txt').
				After that, when the second <code>task</code> expression is evaluated,  <code>out &lt;- intermediate</code> is also true, since 'inter.txt' is newer than 'out.txt'.
				As a result, both tasks are re-executed, even though 'out.txt' is up to date with respect to 'in.txt'.
				This can be a problem, particularly if each task requires several hours of execution.
				<br>
				<br>
				There are two ways to solve this, the obvious one is to add a simple 'if' statement surrounding the tasks:
				<br>
				<br>
<pre class="prettyprint">
#!/usr/bin/env bds

inFile       := "in.txt"		
intermediate := "inter.txt"
outFile      := "out.txt"

if( outFile <- inFile) {
  task( intermediate <- inFile) {
    sys echo Creating $intermediate; cat $inFile > $intermediate; sleep 1 ; echo Done $intermediate
  }

  task( outFile <- intermediate ) {
    sys echo Creating $outFile; cat $intermediate > $outFile; echo Done $outFile
  }
}
</pre>

				Although it solves the issue, the code is not elegant.
				<br>
				<br>
				The alternative is to use <code>dep</code> and <code>goal</code>
				<ul>
					<li> <code>dep</code> defines a task exactly the same way as <code>task</code> expression, but it doesn't evaluate if the tasks should be executed or not (it's just declarative). 
        
					<li> <code>goal</code> executes all dependencies nescesary to create an output 
				</ul>
				Example:
				<br>
				<br> File <a href="bds/test_08.bds">test_08.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

inFile       := "in.txt"		
intermediate := "inter.txt"
outFile      := "out.txt"

dep( intermediate <- inFile) {
    sys echo Creating $intermediate; cat $inFile > $intermediate; sleep 1 ; echo Done $intermediate
}

dep( outFile <- intermediate ) {
    sys echo Creating $outFile; cat $intermediate > $outFile; echo Done $outFile
}

goal outFile
</pre>

			If we execute this script
<pre class="prettyprint">
# Delete old files (if any)
$ rm *.txt

# Create input file
$ date > in.txt

# Run script (both tasks should be executed)
$ ./test_08.bds
Creating out.txt
Done out.txt
Creating inter.txt
Done inter.txt
</pre>
			Now we delete 'inter.txt' and re-execute

<pre class="prettyprint">
# Delete intermediate file
$ rm inter.txt 

# Run again (out.txt is still up to date with respect to in.txt, so no task should be executed)
$ ./test_08.bds
$ 
</pre>

			As you can see, no task is executed the second time, since 'out.txt' is up to date, with respect to 'in.txt'. 
			The fact that intermediate file 'inter.txt' was deleted, is ignored, which is what we wanted.

			</div>
				
			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="sys">Sys </h1>
				<p class="lead"> Local, immediate command execution.  <p>

				A few rules about <code>sys</code> expression:
				<ul>
					<li> Everything after <code>sys</code> until the end of the line is interpreted to be a command
					<li> If the line ends with a backslash, next line is interpreted as part of the same command (same as in a shell script)
					<li> Variables are interpolated. E.g. <code> sys echo Hello $person</code> will replace '$person' by the variable's name before sending it to the OS for execution.
					<li> BDS immediately executes the OS command in the local machine and waits until the command finishes execution.
					<li> If the command exits with an error condition, then <code>bds</code> creates a checkpoint, and exits with a non-zero exit code.
					<li> No resource accounting is performed, the command is executed even if all CPUs are busy executing tasks.
				E.g.
<pre class="prettyprint">
$ cat z.bds
print("Before\n")
sys echo Hello
print("After\n")

$ bds z.bds
Before
Hello
After
</pre>

				<li> Everything after a <code>sys</code> keyword until the end of the line is considered part of the command to be executed.
				So multiple shell commands can be separated by semicolon
<pre class="prettyprint">
sys echo Hello ; echo Bye
</pre>

				<li> Multi-line statements are allowed, by using a backslash at the end of the line (same as a shell script)

<pre class="prettyprint">
sys echo HeLLo \
	| tr [A-Z] [a-z] \
	| grep hell
</pre>
				<li> <code>sys</code> returns the STDOUT of the command:
				<br> File <a href="bds/test_12.bds">test_12.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

dir := sys ls *.bds | head -n 3
print("\nVariable dir is:\n$dir\n")
</pre>

				Executing, we get:
<pre class="prettyprint">
$ ./test_12.bds 
test_01.bds
test_02.bds
test_03.bds

Variable dir is:
test_01.bds
test_02.bds
test_03.bds
</pre>
                Note that (roughly) the first half of the output is printed by the command execution, while the second half is printed by the <code>print</code> statement (i.e. printing the variable <code>dir</code>).

				<li> Characters are passed literally to the interpreting shell. 
					 For example, when you write '\t' it is NOT converted to a tab character before sending it to the shell (no escaping is required):
<pre>
$ cat z.bds
sys echo -e "Hello\tWorld" | awk '{print $1 "\n" $2}'

$ bds z.bds
$ bds z.bds
Hello
World

</pre>
				</ul>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="taskExpr">Task </h1>
				<p class="lead"> Queued command execution with resource management. </p>

				A <code>task</code>expression, just like <code>sys</code> expression, also executes a command.
				The main difference is that a <code>task</code> is "scheduled for execution" instead of executed immediately.
				Task execution order is not guaranteed but <code>bds</code> provides a mechanism for creating task dependencies by means of <code>wait</code> statements.
				<br>
				<br>
				A task expression either performs basic resource management or delegates resource management to cluster management tools.
				The idea is that if you schedule a hundred tasks, but you are executing on your laptop which only has 4 CPUs, then <code>bds</code> will only execute 4 tasks at a time (assuming each task is declared to consume 1 CPU).
				The rest of the tasks are queued for later execution.
				As executing tasks finish and CPUs become available, the remaining tasks are executed.
				<br>
				Similarly, if you schedule 10,000 tasks for execution, but your cluster only has 1,000 cores, then only 1,000 tasks will be executed as a given time.
				Again, other tasks are queued for later execution, but in this case, all the resource management is done by your cluster's workload management system (e.g. GridEngine, PBS, Torque, etc.).
				<br>
				<br>
				<i class="icon-warning-sign"></i> Most cluster resource management do not guarantee that tasks are executed in the same order as queued.
				Even if they do or if they are executed in the same host, a task can start execution and immediately be preempted. 
				So the next task in the queue can effectively start before the previous one.
				<br>
				<br>
				There are different ways to execute tasks<br>
				<table class="table table-striped">
					<tr>
						<th> System type </th>
						<th> Typical usage </th>
						<th> How it is done </th>
					</tr>
					<tr>
						<td> <code>local</code> </td>	
						<td> Running on a single computer. E.g. programming and debugging on your laptop or running stuff on a server </td> 
						<td> A local queue is created, the total number of CPUs used by all tasks running is less or equal than the number of CPU cores available </td> 
					</tr>
					<tr>
						<td> <code>ssh</code> </td>	
						<td> A server farm or a bunch of desktops or servers without a workload management system (e.g. computers in a University campus) </td>
						<td> Basic resource management is performed by logging into all computers in the 'cluster' and monitoring resource usage. </td>
					</tr>
					<tr> 
						<td> <code>cluster</code> </td>
						<td> Running on a cluster (GridEngine, Torque) </td>
						<td> Tasks are scheduled for execution (using 'qsub' or equivalent command). Resource management is delegated to cluster workload management. </td>
					</tr>
					<tr> 
						<td> <code>moab</code> </td>
						<td> Running on a MOAB/PBS cluster </a> </td>
						<td> Tasks are scheduled for execution (using 'msub'). Resource management is delegated to cluster workload management. </td>
					</tr>
					<tr> 
						<td> <code>pbs</code> </td>
						<td> Running on a PBS cluster </a> </td>
						<td> Tasks are scheduled for execution (using 'msub'). Resource management is delegated to cluster workload management. </td>
					</tr>
					<tr> 
						<td> <code>sge</code> </td>
						<td> Running on a SGE cluster </a> </td>
						<td> Tasks are scheduled for execution (using 'qsub'). Resource management is delegated to cluster workload management. </td>
					</tr>
					<tr> 
						<td> <code>generic</code> </td>
						<td> Enable user defined scripts to run, kill and find information on tasks</a> </td>
						<td> This 'generic' cluster allows the user to write/customize scripts that send jobs to the cluster system. 
							 It can be useful to either add cluster systems not currently supported by <code>bds</code>, or to customize parameters and scheduling options beyond what <code>bds</code> allows to customize in the config file.
							 For details, see bds.config file and examples in the project's source code (directories <code>config/clusterGeneric*</code>).
						</td>
					</tr>
					<tr> 
						<td> <code>mesos</code> </td>
						<td> Running on a Mesos framework </a> </td>
						<td> Tasks are scheduled for execution in Mesos framework and resource management is delegated to Mesos. </td>
					</tr>
				</table>
				<br>
				<h3> Scheduling tasks </h3>
				A task is scheduled by means of a <code>task</code> expression.
				A <code>task</code> expression returns a task ID, a string representing a task.
				E.g.:
				<br> File <a href="bds/test_09.bds">test_09.bds</a>
<pre class="prettyprint">
tid := task echo Hello 
print("Task is $tid\n")
</pre>

				Running we get:
<pre class="prettyprint">
$ ./test_09.bds
Task is test_09.bds.20140730_214947_810/task.line_3.id_1
Hello
</pre>

				<code>task</code> is non-blocking, which means that <code>bds</code> continues execution immediately without waiting for the task to finish.
				So, many tasks can be scheduled by simply invoking a task statement many times. 
				<br>
				Once a <code>task</code> is scheduled, execution order depends on the underliying system and there is absolutely no guarantee about execution order (unless you use a <code>wait</code> statements or other dependency mechanism).
				<br>
				E.g., this example shows clearly all the tasks are NOT executed in order, even on local computers:
				<br> File <a href="bds/test_10.bds">test_10.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

for( int i=0 ; i < 10 ; i++ ) task echo Hi $i
</pre>

<pre class="prettyprint">
$ ./test_10.bds
Hi 0
Hi 5
Hi 4
Hi 3
Hi 2
Hi 1
Hi 7
Hi 6
Hi 9
Hi 8
</pre>

			<h3> Resource consumption and task options</h3>
			Often <code>task</code> requires many CPUs or resources.
			In such case, we should inform the resource management system in order to get an efficient allocation of resources (plus many cluster systems kill tasks that fail to report resources correctly).
			<br>
			E.g., In this example we allocate 4 CPUs per task and run it on an 8-core computer, so obviously only 2 tasks can run at the same time:
				<br> File <a href="bds/test_11.bds">test_11.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

for( int i=0 ; i < 10 ; i++ ) {
    # Inform resource management that we need 4 core on each of these tasks
    task ( cpus := 4 ) {
        sys echo Hi $i ; sleep 1; echo Done $i
    }
}
</pre>

			Executing on my 8-core laptop, you can see that only 2 tasks are executed each time (each task is declared to require 4 cpus)
<pre class="prettyprint">
$ ./test_11.bds
Hi 0
Hi 1
Done 0
Done 1
Hi 3
Hi 2
Done 2
Done 3
Hi 4
Hi 5
Done 4
Done 5
Hi 6
Hi 7
Done 6
Done 7
Hi 9
Hi 8
Done 8
Done 9
</pre>
				<br>
				List of resources or task options
				<table class="table table-striped">
					<tr>
						<th> Variable name </th>
						<th> Default value </th>
						<th> Resource / Task options </th>
					</tr>
					<tr>
						<td> <code>cpus</code> </td>	
						<td> 1 </td> 
						<td> Number of CPU (cores) used by the process. </td> 
					</tr>
					<tr>
						<td> <code>allowEmpty</code> </td>	
						<td> false </td> 
						<td> If true, empty files are allowed in task's outputs. This means that a task producing empty files does not result in program termination and checkpointing. </td> 
					</tr>
					<tr>
						<td> <code>canFail</code> </td>	
						<td> false </td> 
						<td> If true, a task is allowed to fail. This means that a failed task execution does not result in program termination and checkpointing. </td> 
					</tr>
					<tr>
						<td> <code>timeout</code> </td>	
						<td> 0 </td> 
						<td> Number of seconds that a process is allowed to execute. Ignored if zero or less. If process runs more than <code>timeout</code> seconds, it is killed. </td> 
					</tr>
					<tr>
						<td> <code>node</code> </td>	
						<td>  </td> 
						<td> If possible this task should be executed on a particular cluster node. This option is only used for cluster systems and ignored on any other systems. </td> 
					</tr>
					<tr>
						<td> <code>queue</code> </td>	
						<td>  </td> 
						<td> Queue name of preferred execution queue (only for cluster systems). </td> 
					</tr>
					<tr>
						<td> <code>retry</code> </td>	
						<td> 0 </td> 
						<td> Number of times a task can be re-executed until it's considered failed. </td> 
					</tr>
					<tr>
						<td> <code>taskName</code> </td>	
						<td>  </td> 
						<td> Assign a task name. This adds a label to the task as well as the taskId returned by <code>task</code> expression. Task ID is used to create log files related to the task (shell script, STDOUT, STDERR and exitCode files) so those file names are also changed. This makes it easier to find tasks in the final report and log files (it has no effect other than that). Note: If taskName contains non-allowed characters, they are sanitized (replaced by '_').</td> 
					</tr>
				</table>

				<h3> Conditional execution </h3>
				Conditional execution of tasks can, obviously, be achieved using an <code>if</code> statement.
				Since conditional execution is so common, we allow for some syntactic sugar by <code> task( expression1, expression2, ... ) { ... } </code>.
				where <code>expression1</code>, <code>expression2</code>, etc. are either boolean expressions or variable declarations.
				The task is executed only if all <code>bool</code> expressions are <code>true</code>.
				<br>
				So the following programs are equivalent
<pre class="prettyprint">
shouldExec := true
if( shouldExec ) {
	task( cpus := 4 ) {
		sys echo RUNNING
	}
}
</pre>
				Is the same as:

<pre class="prettyprint">
shouldExec := true

task( shouldExec, cpus := 4 ) {
	sys echo RUNNING
}
</pre>

				<i class="icon-warning-sign"></i> This feature is particularly useful when combined with the dependency operator <code>&lt;-</code>. 
				For instance, the following <code>task</code> will be executed only if 'out.txt' needs to be updated with respect to 'in.txt'
<pre class="prettyprint">
in  := 'in.txt'
out := 'out.txt'

task( out <- in , cpus := 4 ) {
	sys echo $in > $out
}
</pre>

				<h3> Syntax sugar </h3>
				There are many ways to write task expressions, here we show some examples.

				<ul>
					<li> A simple task 
<pre class="prettyprint">
task echo RUNNING
</pre>
					<li> The same simple task
<pre class="prettyprint">
task {
	sys echo RUNNING
}
</pre>
					<li> A simple, multi-line task (a backslash at the end of the line continues in the next line, just like in a shell script)
<pre class="prettyprint">
task cat file.txt \
		| grep "^results" \
		| cut -f 2 \
		| sort \
		> out.txtx
</pre>
					<li> A more complex multi-line task (sys commands are just multiple lines in a bash script)
<pre class="prettyprint">
task {
	sys cat file.txt | grep "^results" > out.txt
	sys cat other.txt | grep "^exclude" > words.txt
	sys grep -v -f words.txt out.txt > excluded.txt
	sys wc -l excluded.txt
}
</pre>
					<li> A task with dependencies
<pre class="prettyprint">
task ( out <- in ) {
	sys cat $in | grep "^results" > $out
	sys cat other.txt | grep "^exclude" > words.txt
	sys grep -v -f words.txt $out > excluded.txt
	sys wc -l excluded.txt
}
</pre>
					<li> A task with multiple inputs and outputs dependencies
<pre class="prettyprint">
task ( [out1, out2] <- [in1, in2] ) {
	sys cat $in1 | grep "^results" > $out1
	sys cat $in1 $in2 | wc -l > $out2
}
</pre>
					<li> A task with multiple inputs and outputs dependencies, using 4 CPUs and declaring a local variable 'tmp'
<pre class="prettyprint">
task ( [out1, out2] <- [in1, in2] , cpus := 4 , tmp := "$in1.tmp" ) {
	sys cat $in1 | grep "^results" > $out1
	sys cat $in1 $in2 > $tmp
	sys wc -l $tmp | wc -l > $out2
}
</pre>
					<li> A task with a label (<code>taskName</code>) is easier to find in the report
<pre class="prettyprint">
task ( out <- in, cpus := 4 , taskName := "Filter results" ) {
	sys cat $in | grep "^results" > $out
}
</pre>
				</p>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="waitExpr">Wait </h1>
				<p class="lead"> Task coordination mechanisms rely on waiting for some tasks to finish before starting new ones.</p>
				As we mentioned several times, task execution order is not guaranteed.
				<br> File <a href="bds/test_13.bds">test_13.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

for( int i=0 ; i < 10 ; i++ ) task echo BEFORE $i
for( int i=0 ; i < 10 ; i++ ) task echo AFTER $i
</pre>

<pre class="prettyprint">
$ ./test_13.bds
BEFORE 0
BEFORE 4
BEFORE 3
BEFORE 2
BEFORE 1
BEFORE 5
BEFORE 7
BEFORE 6
BEFORE 8
AFTER 1
AFTER 0
BEFORE 9	<-- !!!
AFTER 6
AFTER 5
AFTER 4
AFTER 3
AFTER 2
AFTER 7
AFTER 8
AFTER 9
</pre>
				If a task must be executed after another task finishes, we can introduce a <code>wait</code> statement.
				<br> File <a href="bds/test_13.bds">test_13.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

for( int i=0 ; i < 10 ; i++ ) task echo BEFORE $i

wait    # Wait until ALL scheduled tasks finish
print("We are done waiting, continue...\n")

for( int i=0 ; i < 10 ; i++ ) task echo AFTER $i

</pre>

				Now, we are sure that all tasks 'AFTER' really run after 'BEFORE'
<pre class="prettyprint">
$ ./test_14.bds 
BEFORE 0
BEFORE 2
BEFORE 1
BEFORE 4
BEFORE 3
BEFORE 5
BEFORE 6
BEFORE 7
BEFORE 8
BEFORE 9
We are done waiting, continue...
AFTER 0
AFTER 1
AFTER 2
AFTER 3
AFTER 4
AFTER 5
AFTER 6
AFTER 7
AFTER 8
AFTER 9
</pre>
				We can also wait for a specific task to finish by providing a task ID <code>wait taskId</code>, e.g.:
<pre class="prettyprint">
string tid = task echo Hi
wait tid	# Wait only for one task
</pre>

				Or you can wait for a list of tasks. 
				For instance, in this program, we create a list of two task IDs and <code>wait</code> on the list:
<pre class="prettyprint">
string[] tids

for( int i=0 ; i < 10 ; i++ ) {
	# Tasks that wait a random amount of time
	int sleepTime = randInt( 5 )
	string tid = task echo BEFORE $i ; sleep $sleepTime ; echo DONE $i

	# We only want to wait for the first two tasks
	if( i < 2 ) tids.add(tid)
}

# Wait for all tasks in the lists (only the first two tasks)
wait tids
print("End of wait\n")
</pre>

				When we run it, we get:
<pre class="prettyprint">
$ bds z.bds
BEFORE 2
BEFORE 0
BEFORE 7
BEFORE 5
BEFORE 6
BEFORE 4
BEFORE 3
BEFORE 1
DONE 0
DONE 3
DONE 4
DONE 5
DONE 6
DONE 7
BEFORE 8
BEFORE 9
DONE 1
End of wait		<- Wait finished here
DONE 2
DONE 8
DONE 9
</pre>

				<i class="icon-warning-sign"></i> There is an implicit <code>wait</code> statement at the end of the program. 
				So a program does not exit until all tasks have finished running.
				<br>
				<br>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="dep">Dependency operator </h1>
				<p class="lead"> You can use a dependency operator <code>&lt;-</code> to decide whether tasks should be run or not, based on file existence and time-stamps.  </p>

				The dependency operator is written as <code> out &lt;- in</code>.
				It is true if <code>out</code> file needs to be created or updated.
				This means that the operator is true if any of the following is satisfied:
				<ul>
					<li> <code>out</code> file does not exist
					<li> <code>out</code> file is empty (has zero length)
					<li> <code>out</code> latest modification time is earlier than <code>in</code> latest modification time
				</ul>
				<br> File <a href="bds/test_15.bds">test_15.bds</a>
<pre class="prettyprint">
in  := "in.txt"
out := "out.txt"
if( out <- in ) print("We should update $out\n")
</pre>

				Running the script:
<pre class="prettyprint">
$ touch in.txt              # Create in.txt
$ ./test_15.bds
We should update out.txt

$ touch out.txt             # Create zero length out.txt
$ ./test_15.bds
We should update out.txt

$ ls > out.txt              # Create a non-empty out.txt
$ ./test_15.bds
$                           # Nothing done

$ echo hi > in.txt          # Update in.txt
$ ./test_15.bds
We should update out.txt    # Logically, out needs updating
</pre>
				<br>
				<i class="icon-hand-right"></i> In the dependency operator, <code>in</code> and <code>out</code> can be lists of files. 
				The same rules apply: The operator is true if any out file is missing, zero length or the minimum of modification times in <code>out</code> is less than the maximum modificaton times in <code>in</code>
				<br>
				<br>
				This can be also used on lists:
<pre class="prettyprint">
in1 := "in1.txt"
in2 := "in2.txt"
out := "out.txt"

if( out <- [in1, in2] ) print("We should update $out\n")
</pre>
				or even:
<pre class="prettyprint">
in1 := "in1.txt"
in2 := "in2.txt"
out1 := "out1.txt"
out2 := "out2.txt"

if( [out1, out2] <- [in1, in2] ) print("We should update $out1 and $out2\n")
</pre>
				<br>
				A typical usage of <code>&lt;-</code> is in conjunction with <code>task</code>.
				E.g.
<pre class="prettyprint">
task( out <- in ) {
    sys cat $in > $out
}
</pre>
				The command is executed only if <code>out</code> need updating
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="goal">Goals </h1>
				<p class="lead"> Complex dependencies can be defined using <code>goal</code> and <code>dep</code> </p>

				<code>goal</code> and <code>dep</code> are used to express dependencies in a declarative manner.
				As opposed to <code>task</code> expression, which are evaluated immediately, <code>dep</code> can be used to define a dependency (using the same syntax as <code>task</code>). 
				A <code>dep</code> is not evaluated until a <code>goal</code> requires that dependency to be triggered.
				<br>
				<br> E.g.: File <a href="bds/test_18.bds">test_18.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

in   := 'in.txt'
mid1 := 'mid1.txt'
mid2 := 'mid2.txt'
out  := 'out.txt'

stime := 3

# Dependencies: There is no need declare them in order
dep( out <- mid2 )     sys echo $mid2 > $out  ; echo OUT   ; sleep 1
dep( mid2 <- mid1 )    sys echo $mid1 > $mid2 ; echo MID2  ; sleep 1
dep( mid1 <- in )      sys echo $in   > $mid1 ; echo MID1  ; sleep 1

goal out

</pre>

				Running the code, we get
<pre class="prettyprint">
# Remove old files (if any)
$ rm *.txt

# Create input
$ date > in.txt

$ ./test_18.bds
MID1
MID2
OUT
</pre>

				In this case, <code>bds</code> created a directed acyclic graph of the dependencies needed to satisfy the goal 'out.txt' and then executed the required 'dep' declarations.
				<br>
				<br>
				<b>Note:</b> A <code>goal</code> expression returns a list of task Ids to be executed, which can be quite useful for debugging purposes. So in the previous example you could write:
<pre class="prettyprint">
tids := goal out
print "Executing tasks: $tids\n"
</pre>
				<br>
				<h3> Intermediate files within a 'goal' can be deleted </h3>
				<br>
				In the previous example, if we delete the intermediate files 'mid1.txt' and or 'mid2.txt', and we re-execute the script, <code>bds</code> will notice that the output 'out.txt' is still valid with respect to the input 'in.txt' and will not execute any task.
				<br>
				<br>
<pre class="prettyprint">
# Remove intermediate files
$ rm mid?.txt

# Re-execute (out.txt is still valid because in.txt was not changed)
$ ./test_18.bds
$
</pre>
				<br>
				How this works: <code>bds</code> calculates the dependency graph and checks whether the <code>goal</code> is up to date with respect to the inputs (which are the leaves in the dependency graph).
				If the goal up to date, then nothing is done.
				This feature is particularly useful when intermediate files are large and we need to clean them up (since we are working with big data problems, this is often the case).
				<br>
				<br>
				<h3> Dependencies that do not create files </h3>
				<br>
				What if the final step in your pipeline does not create any files?
				in this case, you can use <code>taskId</code> as a goal, for example:
				<br>
				<br>
<pre class="prettyprint">
#!/usr/bin/env bds

tid := dep( taskName := 'hi' ) {
    sys echo Hello
}

goal tid	# We use task Id instead of a file name
</pre>
				<br>
				<br>
				<h3> Multiple goals </h3>
				<br>
				Sometimes it is convenient to fire multiple goals at once. You can do this by passing a list, instead of a string, to <code>goal</code>.
				<br>
				<br>
<pre class="prettyprint">
#!/usr/bin/env bds

string[] outs
for(int i=0; i < 3 ; i++ ) {
    in := "in.$i.txt"
    out := "out.$i.txt"
    outs += out

    sys date > $in
    dep( out <- in ) sys cat $in > $out ; echo Hi $i
}

goal outs	# We use a list of goals, it is interpreted as multiple goal statements (one for each item in the list)
</pre>

			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="remote">Remote files (Amazon S3, Http, etc.) </h1>
				<p class="lead"> Often applications need to run tasks on remote data files, <code>bds</code> can transparently handle remote data dependencies</p>

				In many cases data files may reside in non-local file systems, such as <code>HTTP</code> or Amazon's <code>S3</code> object storage.
				Fortunately <code>bds</code> can transparently handle remote dependencies, download the input files and upload the results without you having to write a single line of code.
				<br>
				<br>
				<b>Example 1:</b> In this example, the remote file <code>index.html</code> is remote input file to the <code>task</code>.
				Obviously <code>index.html</code> is hosted on GitHub's servers, thus not available on the computer where the script is running.
				Before the command (<code>cat</code>) is executed, the remote file is transparently downloaded by <code>bds</code>.
				<br>
				<br>
<pre class="prettyprint">
in  := 'http://pcingola.github.io/BigDataScript/index.html'
out := 'tmp.html'

task( out <- in ) sys cat $in > $out
</pre>
				<br>
				Notice that: 
				<ol>
					<li> there is no code for downloading the remote file (<code>index.html</code>) in the script;
					<li> the file is downloaded on the processing node performing the task, which may differ from the node running the script (e.g. if it is running on a cluster);
					<li> task dependencies are verified without downloading data, so the task, as well as the corresponding download / upload operations, are only performed if required;
					<li> if the file is required in the future, <code>bds</code> checks if the local (cached) copy is still valid, and uses the cached file if possible (saving bandwith and time).
				</ol>
				<br>
				<b>Example 2:</b> The following example is slightly more complicated, the input ('index.html') is processed (<code>cat</code> and <code>echo</code> commands) and the results are stored in an <code>Amazon S3</code> object.
				Once more, notice that <code>bds</code> transparently takes care of downloading the file and then uploading the output to Amazon's S3.
				<br>
				<br>
<pre class="prettyprint">
in  := 'http://pcingola.github.io/BigDataScript/index.html'
out := 's3://pcingola.bds/test_remote_12.txt'

task( out <- in ) {
	sys cat $in > $out
	sys echo "This line is appended to the file" >> $out
}
</pre>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="par">Parallel execution <code>par</code> </h1>
				<p class="lead"> <code>bds</code> can run parallel code as threads in the same program.</p>
				<br>
				Sometimes multiple branches of an analysis pipeline must be run in parallel. 
				<code>bds</code> provides a simple <code>par</code> expression to run code in parallel.
				Originally this was called <code>parallel</code>, but then I realized I was too lazy to type all those letters, so I reduced it to <code>par</code> (both of them work if you choose to be more verbose).
				<br> 
				<br> E.g.: File <a href="bds/test_16.bds">test_16.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

par {
    # This block runs in parallel
    for( int i : range(1, 5) ) {
        print("Parallel $i\n")
        sleep( 0.2 )
    }
}

for( int i : range(1, 5) ) {
    print("Main $i\n")
    sleep( 0.2 )
}
</pre>

				If we run this code:

<pre class="prettyprint">
$ ./test_16.bds
Parallel 1
Main 1
Parallel 2
Main 2
Main 3
Parallel 3
Main 4
Parallel 4
Parallel 5
Main 5
</pre>

			Perhaps a more elegant way to write the same code would be:

<pre class="prettyprint">
#!/usr/bin/env bds

void count(string msg) {
    for( int i : range(1, 5) ) {
        print("$msg $i\n")
        sleep( 0.2 )
    }
}

par count('Parallel')   # Call function in parallel thread
count('Main')           # Call function in 'main' thread
</pre>
				<code>par</code> also works with optional expressions that must be all 'true' to evaluate the block.
	
<pre class="prettyprint">
par( out <- in )  {
    # This block runs in parallel if 'out' needs to be updated
    for( int i : range(1, 5) ) {
        tmp := "$in.$i.tmp"
        task head -n $i $in | tail -n 1 > $tmp
    }
    wait
    task cat $in.*.tmp > $out
}
</pre>

				<br>
				<br>
				<h3> Wait in 'par' context </h3>
				<code>par</code> expressions return a 'parallel ID' string that we can use in <code>wait</code> 
<pre class="prettyprint">
pid := par longRunningFunction()    // This function is executed in parallel 

wait pid                            // Wait for parallel to finish
</pre>

				Here <code>wait</code> statement waits until the function "longRunningFunction()" finishes.
				<br>
				<br>
				We mentioned before that, by default, a <code>wait</code> statement with no arguments would wait for 'all' tasks to finish.
				Specifically, <code>wait</code> statement waits for all tasks scheduled by the same thread and for all 'parallels'.
				So, <code>wait</code> statement with no arguments, will not restore execution until all threads and tasks triggered by the current thread have finished.
				<br>
				<br>
				<h3> Calling functions  with 'par' </h3>

				A function can be called in a parallel thread using <code>par</code> statements.
				<br>
				E.g.:
<pre>
par someFunction(x, y)
</pre>
				It is important to notice that the return value from a <code>par</code> it is a 'parallel ID' (i.e. a thread ID) and not the function's return value.
				This is because the parallel thread could take a long time to process and we don't want to stop execution in the current thread until the function finishes.
				<br>
				<br>
				So, this sample code will show the 'parallel ID' independently of the function's return value:
<pre>
pid := par someFunction(x, y)  # 'par' returns a thread ID
print "Parallel ID: $pid\n"
</pre>
				<br>
				<b>Important:</b> When calling a function, arguments are evaluated <b>before</b> the new thread is created. 
				The reason for this is to simplify race conditions.

				<h3> Race conditions in 'par' and how to avoid them </h3>
				As is the case when creating threads in any programming language, using <code>par</code> can lead to race conditions.
				<br>
				As an example, consider this code:
				<br>
<pre class="prettyprint">
#!/usr/bin/env bds

for( int i : range(0, 10) ) {
    par {
        print "Number: $i\n"
    }
}   
</pre>
			The output is (comments added for clarification):
<pre>
$ ./z.bds
Number: 0
Number: 2		# We missed number 1?
Number: 3
Number: 4
Number: 6		# We missed number 5?
Number: 6		# Two '6'?
Number: 8
Number: 8
Number: 10		# Three number 10?
Number: 10
Number: 10
</pre>

			This is clearly not the result we wanted.
			<br>
			What happened? Well, obviously this had a race condition. 
			From the time thread is created (<code>par</code>), until the variable <code>i</code> is evaluated in <code>print</code> statement (parallel thread), the main thread has already changed <code>i</code>'s value.
			<br>
			<br>
			To avoid this type of race condition, when using <code>par</code> to call a function, arguments are evaluated in the current thread.
			Then a new thread is created and the function is invoked.
			See what happens when we refactor the code:
			<br>
<pre class="prettyprint">
#!/usr/bin/env bds

void show(int num) {
    print "Number: $num\n"
}

for( int i : range(0, 10) ) {
    par show(i)
}   
</pre>
			<br>
			Now the output is what we expect:
			<br>
<pre>
$ ./z.bds
Number: 0
Number: 1
Number: 2
Number: 3
Number: 4
Number: 5
Number: 6
Number: 7
Number: 8
Number: 9
Number: 10
</pre>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="check">Checkpoints </h1>
				<p class="lead"> BigDataScript can save the full state of a running script to a file and restart execution from that point </p>

				A <code>checkpoint</code> is the full serialization of the state of a program. 
				This is a powerful tool to create robust pipelines and to recover from several failure conditions.
				<br>
				<br>
				A checkpoint is created either when a task fails or when an explicit <code>checkpoint</code> command is executed.
				E.g.: The following program counts from 0 to 9, creating a checkpoint when the counter gets to 5
				<br> File <a href="bds/test_19.bds">test_19.bds</a>
<pre class="prettyprint">
for( int i=0 ; i < 10 ; i++ ) {
	if( i == 5 ) {
		print("Checkpoint\n")
		checkpoint "my.chp"
	}
	print("Counting $i\n")
}
</pre>

				If we execute it, we get
<pre class="prettyprint">
$ bds z.bds
Counting 0
Counting 1
Counting 2
Counting 3
Counting 4
Checkpoint
Counting 5
Counting 6
Counting 7
Counting 8
Counting 9
</pre>
				A checkpoint file <code>my.chp</code> created.
				We can restart execution from this checkpoint file, by using the <code>bds -r</code> command line option
<pre class="prettyprint">
$ bds -r my.chp		# Restart execution from checkpoint file
Counting 5
Counting 6
Counting 7
Counting 8
Counting 9
</pre>

				You can also see information on what was happening when the checkpoint was created:
<pre class="prettyprint">
$ bds -i my.chp
Program file: './test_19.bds'
     1 |#!/usr/bin/env bds
     2 |
     3 |for( int i=0 ; i < 10 ; i++ ) {
     4 |	if( i == 5 ) {
     5 |		print("Checkpoint\n")
     6 |		checkpoint
     7 |	}
     8 |	print("Counting $i\n")
     9 |}

Stack trace:
test_19.bds, line 3 :	for( int i=0 ; i < 10 ; i++ ) {
test_19.bds, line 4 :		if( i == 5 ) {
test_19.bds, line 6 :			checkpoint

--- Scope: ./test_19.bds:3 ---
int i = 5
...
</pre>
				<br>
				You can even copy the file(s) to another computer and restart execution there, as shown in this video
				<br>
				<iframe width="640" height="390" src="https://www.youtube.com/embed/ah1XxWTYSLM" frameborder="0" allowfullscreen></iframe>
				<br>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="test">Test cases</h1>
				<p class="lead"> Because nobody writes perfect code. </p>

				<code>bds</code> provides a simple unit testing functionality. 
				Simply use the <code>-t</code> command line option and <code>bds</code> will run all functions <code>test*()</code> (that is functions whose names start with 'test' and have no arguments).
	
				<br> File <a href="bds/test_24.bds">test_24.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

int twice(int n)    return 3 * n    // Looks like I don't really know what "twice" means...

void test01() {
    print("Nice test code 01\n")
}

void test02() {
    i := 1
    i++
    if( i != 2 )    error("I can't add")
}

void test03() {
    i := twice( 1 )
    if( i != 2 )    error("This is weird")
}
</pre>

				When we execute the tests, we get
<pre class="prettyprint">
$ bds -t ./test_24.bds 

Nice test code 01
00:00:00.002	Test 'test01': OK

00:00:00.003	Test 'test02': OK

00:00:00.004	Error: This is weird
00:00:00.004	Test 'test03': FAIL

00:00:00.005	Totals
                  OK    : 2
                  ERROR : 1

</pre>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="debugger"> Debugger (built in) </h1>
				<p class="lead"> Bds provides a simple yet powerful built in debugger using <code>breakpoint</code> and <code>debug</code> statements.</p>

				<code>bds</code> provides a simple built in debugger that can be activated using <code>breakpoint</code> statement.
				When a <code>breakpoint</code> statement is found, <code>bds</code> switches to debug mode and prompts the user on the console.
	
				<br> File <a href="bds/test_24.bds">test_25.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

int inc(int x) {
    return x + 1;
}

debug "This won't be printed because we are not (yet) in debug mode\n" 
breakpoint "Activate debug mode and insert a breakpoint here!\n"

for( int i=0 ; i < 3 ; i = inc(i) ) {
    print "hi $i\n"
    debug "Variable: $i\n"  # This will be printed
}
</pre>

				When we run this example, the program runs until the first <code>breakpoint</code> and then <code>bds</code> prompts for debug commands on the console:
<pre class="prettyprint">
$ bds test_25.bds 
Breakpoint test_25.bds, line 8: Activate debug mode and insert a breakpoint here!
DEBUG [STEP]: test_25.bds, line 10: 
	for( int i = 0 ; i < 3 ; i = inc( i ) ) {
		print "hi $i\\n"
		debug "Variable: $i\\n"
	}
>
</pre>

			You can type 'h' for help in debug commands:
<pre>
> h
Help:
	[RETURN]  : step
	f         : show current Frame (variables within current scope)
	h         : Help
	o         : step Over
	p         : show Program counter
	r         : Run program (until next breakpoint)
	s         : Step
	t         : show stack Trace
	v varname : show Variable 'varname'
</pre>

			Here is an example of a debug session (comments after '#' added for clarity):
<pre>
$ bds test_25.bds 
Breakpoint test_25.bds, line 8: Activate debug mode and insert a breakpoint here!
DEBUG [STEP]: test_25.bds, line 10: 
    for( int i = 0 ; i < 3 ; i = inc( i ) ) {
        print "hi $i\\n"
        debug "Variable: $i\\n"
    }
> 
DEBUG [STEP]: test_25.bds, line 10: int i = 0 >                      # Pressing Return runs the next step ('int i=0')
DEBUG [STEP]: test_25.bds, line 10: i = 0 > v i                      # Show variable 'i'
int : 0
DEBUG [STEP]: test_25.bds, line 10: i < 3 > 
DEBUG [STEP]: test_25.bds, line 11: print "hi $i\\n" > 
hi 0                                                                 # Output to STDOUT from print statement
DEBUG [STEP]: test_25.bds, line 12: debug "Variable: $i\\n" > 
Debug test_25.bds, line 12: Variable: 0                              # Since we are in debug mode, 'debug' prints to SDTERR
DEBUG [STEP]: test_25.bds, line 10: i = inc( i ) > 
DEBUG [STEP]: test_25.bds, line 10: inc( i ) >                       # Step into function 'inc(i)'
DEBUG [STEP]: test_25.bds, line 4: return x + 1 > t                  # Show stack trace
test_25.bds, line 10 :    for( int i=0 ; i < 3 ; i = inc(i) ) {
test_25.bds, line 3 :    int inc(int x) {
test_25.bds, line 4 :        return x + 1;

DEBUG [STEP]: test_25.bds, line 4: return x + 1 > f                  # Show frames (variables)

---------- Scope Global ----------
string _ = "/Users/pcingola/.bds/bds"
...                                                                  # Edited for brevity
int walltimeout = 86400
int week = 604800

---------- Scope test_25.bds:10:ForLoop ----------                   
int i = 0

---------- Scope test_25.bds:3:FunctionDeclaration ----------
int x = 0

DEBUG [STEP]: test_25.bds, line 4: return x + 1 >                    # Step, exeute 'return' statement
DEBUG [STEP]: test_25.bds, line 10: i < 3 > 
DEBUG [STEP]: test_25.bds, line 11: print "hi $i\\n" > 
hi 1
DEBUG [STEP]: test_25.bds, line 12: debug "Variable: $i\\n" > 
Debug test_25.bds, line 12: Variable: 1
DEBUG [STEP]: test_25.bds, line 10: i = inc( i ) > o
DEBUG [STEP_OVER]: test_25.bds, line 10: inc( i ) >                  # Step Over: execute 'inc(i)' and stop after function returns
DEBUG [STEP_OVER]: test_25.bds, line 10: i < 3 > 
DEBUG [STEP_OVER]: test_25.bds, line 11: print "hi $i\\n" > r        # Run (until another breakpoint). Since there are no more breakpoints, runs until the end of the program
hi 2
Debug test_25.bds, line 12: Variable: 2
</pre>
			</div>
		
			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="cmdLineParse">Automatic command line parsing </h1>
				<p class="lead"> No need to manually parse command line options for your scripts, <code>bds</code> does it for you.</p>

				Automatic command line parsing parses any command line argument that starts with "-" and assigns the value to the corresponding variable.
				<br> File <a href="bds/test_20.bds">test_20.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

in := "in.txt"
print("In file is '$in'\n")
</pre>

				If we run this, we get
<pre class="prettyprint">
$ ./test_20.bds 
In file is 'in.txt'
</pre>

				Now we pass a command line argument <code>-in another_file.txt</code>, and <code>bds</code> automatically parses that command line option replacing the value of variable 'in'
<pre class="prettyprint">
$ ./test_20.bds -in another_file.txt
In file is 'another_file.txt'
</pre>

				This feature also works for other data types (int, real, bool). 
				In case of bool if the option is present, the variable is set to 'true'.
				<br> File <a href="bds/test_21.bds">test_21.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

bool flag
print("Variable flag is $flag\n")
</pre>

<pre class="prettyprint">
$ ./test_21.bds
Variable flag is false
</pre>

<pre class="prettyprint">
$ ./test_21.bds -flag
Variable flag is true
</pre>

				Or you can specify the value (<code>true</code> or <code>false</code> which is useful to set to <code>false</code> a bool that is by default <code>true</code>:
				<br> File <a href="bds/test_21b.bds">test_21b.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

flagOn  := true
flagOff := false
print("flagOn = $flagOn\nflagOff = $flagOff\n")
</pre>

				So in this example we can reverse the defaults by running this (note that we can use <code>-flagOff</code> instead of <code>-flagOff true </code>):
<pre class="prettyprint">
$ ./test_21b.bds -flagOn false -flagOff true 
flagOn = false
flagOff = true
</pre>
				Note that we can use <code>-flagOff</code> instead of <code>-flagOff true</code> (the outcome is the same).

				<br>
				<br>
				You can also apply this to a list of strings.
				In this case, all command line arguments following the <code>-listName</code> will be included in the list (up to the next argument starting with '-').
				<br>
				E.g.: Note that list <code>in</code> is populated using 'in1.txt in2.txt in3.txt' and <code>out</code> is set to 'zzz.txt'
				<br> File <a href="bds/test_22.bds">test_22.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

in  := ["in.txt"]
out := "out.txt"
ok	:= false

print("In : $in\n")
print("Out: $out\n")
print("OK : $ok\n")
</pre>

<pre class="prettyprint">
$ ./test_22.bds  -ok -in in1.txt in2.txt in3.txt -out zzz.txt
In : [in1.txt, in2.txt, in3.txt]
Out: zzz.txt
OK : true
</pre>

				<iframe width="640" height="390" src="http://www.youtube.com/embed/oSjhkRuc0I8" frameborder="0" allowfullscreen></iframe>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="autoHelp">Automatic command line help </h1>
				<p class="lead"> A command line 'help' for your scripts can be created automatically by <code>bds</code>. </p>

				When you create variables that are used in command line arguments, you can provide an optional <code>help</code> string that <code>bds</code> will show when the script is run using either: <code>-h</code>, <code>-help</code> or <code>--help</code> command line options.
				<br>
				<br>
				For example, if we have the following script:<br>
				File <a href="bds/test_26.bds">test_26.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

int num = 3		help Number of times 'hi' should be printed
int min			help Help for argument 'min' should be printed here
mean := 5		help Help for argument 'mean' should be printed here
someVeryLongCommandLineArgumentName := true    help This command line argument has a really long name

for( int i=0 ; i < num ; i++ ) {
	print "hi $i\n"
}
</pre>

		When running the script using <code>-h</code> command line option a help screen is created and printed out automatically (no action is programmed in the script to process the '-h' command line option).
		Note that script command line options are given AFTER script name:
<pre>
$ bds test_26.bds -h
Command line options 'test_26.bds' :
	-num <int>                                : Number of times 'hi' should be printed
	-min <int>                                : Help for argument 'min' should be printed here
	-mean <int>                               : Help for argument 'mean' should be printed here
	-someVeryLongCommandLineArgumentName      : This command line argument has a really long name
</pre>

		<br>
		The same happens if you run the script directly:
<pre>
$ ./test_26.bds -h
Command line options 'test_26.bds' :
	num                                 : Number of times 'hi' should be printed
	min                                 : Help for argument 'min' should be printed here
	mean                                : Help for argument 'mean' should be printed here
	someVeryLongCommandLineArgumentName : This command line argument has a really long name
</pre>
				<br>
				<h3> Help sort order </h3>
				By default, variables are sorted alphabetically when help is shown. 
				This can be overridden by creating a global variable <code>helpUnsorted</code> (regardless of its type and value, since the program may not even be running when the help is shown).
				<br>
				File <a href="bds/test_26b.bds">test_26b.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

# This variable is use to indicate that help should be shown unsorted 
# (i.e. in the same order that variables are declared)
helpUnsorted := true

zzz := 1        help Help for argument 'zzz' should be printed here
aaa := 1        help Help for argument 'aaa' should be printed here

print "Done\n"
</pre>

				Now when we run <code>bds -h</code> help lines are shown unsorted:
<pre>
$ ./test_26b.bds -h
Command line options 'test_26b.bds' :
	-zzz <int>  : Help for argument 'zzz' should be printed here
	-aaa <int>  : Help for argument 'aaa' should be printed here
</pre>
				<br>
				<h3> Showing help on empty command line arguments </h3>
				The function <code>printHelp()</code> can be called to show the help message. 
				This can be used, for instance, to show a help message when there are no command line arguments by doing something like this:
				<br>
				File <a href="bds/test_26c.bds">test_26c.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

zzz := 1        help Help for argument 'zzz' should be printed here
aaa := 1        help Help for argument 'aaa' should be printed here
bbb := 1        help Help for argument 'bbb' should be printed here

if( args.isEmpty() ) {
    printHelp()
    exit(1)
}

print "Done\n"
</pre>

				Now when we run <code>test_26c.bds</code> without any command line arguments, the help message is shown:
<pre>
$ ./test_26c.bds 
Command line options 'test_26c.bds' :
	-aaa <int>  : Help for argument 'aaa' should be printed here
	-bbb <int>  : Help for argument 'bbb' should be printed here
	-zzz <int>  : Help for argument 'zzz' should be printed here
</pre>
				<br>
				<h3> Help sections </h3>

				Sometimes it is useful to divide the help message into sections.
				Sections are marked by <code>help</code> statements as in this example:
				<br>
				File <a href="bds/test_26d.bds">test_26d.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

help This program does blah
help Actually, a lot of blah blah
help     and even more blah
help     or blah

verbose := false    help Be verbose
quiet   := false    help Be very quiet

help Options related to database
dbPort := 5432      help Database port
dbName := "testDb"  help Database name

print "OK\n"
</pre>
				<br>
				When run, variables are grouped in two "help sections" (note that variables are sorted within each section):
<pre>
$ ./test_26d.bds -h
This program does blah
Actually, a lot of blah blah
    and even more blah
    or blah
	-quiet <bool>     : Be very quiet
	-verbose <bool>   : Be verbose
Options related to database
	-dbName <string>  : Database name
	-dbPort <int>     : Database port
</pre>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="autoLog">Logging </h1>
				<p class="lead"> Logging is mundane and boring, but many times necessary. Not many people enjoy adding hundreds of line of code just to perform logging. That's why <code>bds</code> can log everything for you.</p>

				Both <code>sys</code> and <code>task</code> commands create a shell file, execute it and save STDOUT and STDERR to files.
				This gives you an automatic log of everything that was executed, as well as the details of the outputs and exit status from each execution.
				<br>
				For example, let's create a simple program and run it
<pre class="prettyprint">
string name = "Pablo"

sys echo Hello $name
</pre>

					Now let's run this script, we use <code>-v</code> command line option to make the output verbose:
<pre class="prettyprint">
$ bds -v -log z.bds
00:00:00.169	Process ID: z.bds.20140328_224825_685
00:00:00.174	Queuing task 'z.bds.20140328_224825_685/sys.line_4.id_1'
00:00:00.674	Running task 'z.bds.20140328_224825_685/sys.line_4.id_1'
00:00:00.689	Finished task 'z.bds.20140328_224825_685/sys.line_4.id_1'
Hello Pablo
00:00:00.692	Finished running. Exit value : 0
</pre>
				What happened?
				<ol>
					<li> bds parses the <code>sys</code> statement and interpolates "echo Hello $name" to "echo Hello Pablo"

					<li> Creates a task and assigns a task ID <code>z.bds.20140328_224825_685/sys.line_4.id_1</code>

					<li> It creates a shell script file <code>z.bds.20140328_224825_685/sys.line_4.id_1.sh</code> with the code:
<pre class="prettyprint">
$ cat z.bds.20140328_224825_685/sys.line_4.id_1.sh 
#!/bin/sh

echo Hello Pablo
</pre>

						<li> Then executes this shell script and saves stdout and stderr to z.bds.20140328_224825_685/sys.line_4.id_1.stdout and z.bds.20140328_224825_685/sys.line_4.id_1.stderr respectively
<pre class="prettyprint">
$ cat z.bds.20140328_224825_685/sys.line_4.id_1.stdout
Hello Pablo
$ cat z.bds.20140328_224825_685/sys.line_4.id_1.stderr
</pre>
					Notice that there was no output on stderr (it's empty)

					<li> Command finished without problems, so it continues with the rest of the program
				
				</ol>
				So at the end of the run, we have the file with the script, plus the stdout and stderr files.
				All the information is logged automatically.
				<br>

				</p>

			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="cleanup">Cleanup </h1>
				<p class="lead"> If a script fails, <code>bds</code> automatically cleans up stale files and kills pending tasks. <p>

				In order to make sure that data pipelines are correctly re-executed after a failure, <code>bds</code> automatically cleans all dependent files from failed tasks.
				This saves time because the user doesn't need to check for consistency on putative stale files.
				<br>
				<br>
				Also, <code>bds</code> ensures that resources are not wasted, by killing all pending tasks.
				In large pipelines, thousands of tasks can be scheduled for execution in a cluster and it is quite difficult for the user to keep track of them and clean them if the pipeline fails.
				Fortunately, <code>bds</code> takes care of all these details and issues appropriate commands to kill all pending tasks.

				<br> File <a href="bds/test_22.bds">test_22.bds</a>
<pre class="prettyprint">
#!/usr/bin/env bds

for(int i : range(1,10) ) {
    in  := "in_$i.txt"
    sys date > $in

    out := "out_$i.txt"
    task( out <- in ) {
        sys echo Task $i | tee $out; sleep $i; echo Done $i
    }
}
</pre>

				If I run this example and interrupt it (by pressing Ctrl-C) before it ends:
<pre class="prettyprint">
$ ./test_23.bds
Task 4
Task 5
Task 2
Task 3
Task 8
Task 1
Task 7
Task 6
Done 1
Task 9
Done 2
Task 10
Done 3
^C				# Here I pressed Ctr-C
2014/07/31 00:43:46 bds: Received OS signal 'interrupt'
2014/07/31 00:43:46 bds: Killing PID '32523'
2014/07/31 00:43:46 bds: Killing PID '32534'
2014/07/31 00:43:46 bds: Deleting file 'out_6.txt'
2014/07/31 00:43:46 bds: Deleting file 'out_9.txt'
2014/07/31 00:43:46 bds: Deleting file 'out_5.txt'
2014/07/31 00:43:46 bds: Killing PID '32546'
2014/07/31 00:43:46 bds: Deleting file 'out_4.txt'
2014/07/31 00:43:46 bds: Deleting file 'out_8.txt'
2014/07/31 00:43:46 bds: Killing PID '32597'
2014/07/31 00:43:46 bds: Killing PID '32557'
2014/07/31 00:43:46 bds: Deleting file 'out_7.txt'
2014/07/31 00:43:46 bds: Killing PID '32575'
2014/07/31 00:43:46 bds: Killing PID '32610'
2014/07/31 00:43:46 bds: Deleting file 'out_10.txt'
</pre>
				You can see how <code>bds</code> cleans up all stale files and kills all processes.
				When this is executed in a cluster, the appropriate <code>qdel</code>, <code>canceljob</code> or similar command is issued (depending on the type of cluster used).
	
				<h3 class="page-header" id="myfirst">Disappearing tasks</h3>
				<p class="lead"> Sometimes tasks just disappear from clusters. </p>

				Sometimes clusters fail in ways that the cluster management system is unable to detect, let alone report the error.
				It can happen that tasks disappear without any trace from the cluster (this is not as rare as you may think, particularly when executing thousands of tasks per pipeline).
				For this reason, <code>bds</code> performs active monitoring, to ensure that tasks are still alive.
				If any task "mysteriously disappears", <code>bds</code> reports the problem and considers the task as failed.
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="commandLine">BDS Command line options </h1>
				<p class="lead"> BigDataScript (<code>bds</code>) command line arguments. <p>
					
				Running the bds command without any arguments shows a help message
<pre class="prettyprint">
$ bds
BigDataScript 0.999i (build 2015-03-28), by Pablo Cingolani

Usage: BigDataScript [options] file.bds

Available options: 
  [-c | -config ] bds.config     : Config file. Default : /Users/pcingola/.bds/bds.config
  [-checkPidRegex]               : Check configuration's 'pidRegex' by matching stdin.
  [-d | -debug  ]                : Debug mode.
  -dryRun                        : Do not run any task, just show what would be run. Default: false
  [-extractSource]               : Extract source code files from checkpoint (only valid combined with '-info').
  [-i | -info   ] checkpoint.chp : Show state information in checkpoint file.
  [-l | -log    ]                : Log all tasks (do not delete tmp files). Default: false
  -noReport                      : Do not create any report.
  -noReportHtml                  : Do not create HTML report.
  -noRmOnExit                    : Do not remove files marked for deletion on exit (rmOnExit). Default: false
  [-q | -queue  ] queueName      : Set default queue name.
  -quiet                         : Do not show any messages or tasks outputs on STDOUT. Default: false
  -reportHtml                    : Create HTML report. Default: true
  -reportYaml                    : Create YAML report. Default: false
  [-r | -restore] checkpoint.chp : Restore state from checkpoint file.
  [-s | -system ] type           : Set system type.
  [-t | -test   ]                : Run user test cases (runs all test* functions).
  [-v | -verbose]                : Be verbose.
  -version                       : Show version and exit.
  [-y | -retry  ] num            : Number of times to retry a failing tasks.
  -pid <file>                    : Write local processes PIDs to 'file'
</pre>
				<table class="table table-striped">
					<tr> <th> Option short </th><th> Option long </th> <th> Meaning </th> </tr>
					<tr> <td> -c </td> <td> -config </td> <td> Path to bds.config file (most of the times no config file is needed) </td> </tr>
					<tr> <td>    </td> <td> -checkPidRegex </td> <td> Check configuration's 'pidRegex' by matching stdin. </td> </tr>
					<tr> <td> -d </td> <td> -debug </td> <td> Debug mode, shows detailed information for debugging scripts or debugging bds itself. </td> </tr>
					<tr> <td>    </td> <td> -dryRun  </td> <td> Do not run any task, just show what would be run. This mode is used when you just want to test your script's logic without executing any tasks. </td> </tr>
					<tr> <td>    </td> <td> -extractSource </td> <td> Extract source code files from checkpoint (only valid combined with '-info').</td> </tr>
					<tr> <td> -i </td> <td> -info </td> <td> Show state information in checkpoint file. Prints variables, scopes, etc.</td> </tr>
					<tr> <td> -l </td> <td> -log </td> <td> Log all tasks (do not delete tmp files).</td> </tr>
					<tr> <td>    </td> <td> -noReport </td> Do not create any report.<td> </tr>
					<tr> <td>    </td> <td> -noReportHtml </td> Do not create HTML report.<td> </tr>
					<tr> <td>    </td> <td> -noRmOnExit </td> <td> Do not remove files marked for deletion on exit (rmOnExit). </td> </tr>
					<tr> <td> -q </td> <td> -queue </td> <td> Set default cluster's queue name. </td> </tr>
					<tr> <td>    </td> <td> -quiet </td> <td> Do not show any messages or tasks outputs on STDOUT. This means that only the output from <code>print</code> (and other print-like bds statements), statements will be shown on the console </td> </tr>
					<tr> <td>    </td> <td> -reportHtml </td> <td> Create HTML report. Create an HTML report (only if at least one task is executed). By default this option is activated.</tr>
					<tr> <td>    </td> <td> -reportYaml </td> <td> Create YAML report. Create a YAML report (only if at least one task is executed). </tr>
					<tr> <td> -r </td> <td> -restore </td> <td> Restore from a a checkpoint and continue execution.</td> </tr>
					<tr> <td> -s </td> <td> -system </td> <td> Define the 'system' type the script is running on (e.g. cluster type) </td> </tr>
					<tr> <td> -t </td> <td> -test </td> <td> Perform all tests in a script (i.e. run all functions that are called "test*") </td> </tr>
					<tr> <td> -v </td> <td> -verbose </td> <td> Be verbose (show more information) </td> </tr>
					<tr> <td>    </td> <td> -version </td> <td> Show version number and exit.</td> </tr>
					<tr> <td> -y </td> <td> -retry </td> <td> Number of times to retry a failing tasks. </td> </tr>
					<tr> <td>    </td> <td> -pid </td> <td> Write local processes PIDs to 'file'. Under normal circumstances, you should never use this command line option (unless you are debugging bds itself). </td> </tr>
				</table>
			</div>

			<!-- ================================================== -->
			<div class="bs-docs-section">
				<h1 class="page-header" id="config">BDS Config file </h1>
				<p class="lead"> BigDataScript's config file allows customizing <code>bds</code>'s behavior.</p>

				<p> 
				BigDataScript's config file is usually located in <code>$HOME/.bds/bds.config</code>.
				Running <code>bds</code> without any arguments shows the config's file default location.
				You can provide an alternative path using command line option <code>-c</code>.
				<br>
				<br>
				The config file is roughly divided into sections.
				It is not required that parameters are in specific sections, we just do it to have some order.
				We explain the parameters for each section below.
				<br>
				<br>
				<h3>Default parameters</h3>
				This section defines default parameters used in running tasks (such as system type, number of CPUs, memory, etc.).
				Most of the time you'd rather keep options unspecified but it can be convenient to set <code>system = local</code> in 
				your laptop and <code>system = cluster</code> in your production cluster.

				<table class="table table-striped">
					<tr>
						<th>Parameter</th>
						<th> Comments / examples </th>
					</tr>
					<tr>
						<td> mem </td>
						<td> Default memory in bytes (negative number means unspecified) </td>
					</tr>
					<tr>
						<td> node  </td>
						<td> Default execution node (empty means unspecified)  </td>
					</tr>
					<tr>
						<td> queue  </td>
						<td> Add default queue name (empty means unspecified)  </td>
					</tr>
					<tr>
						<td> retry  </td>
						<td> Default number of retries when a task fails (0 means no retry). 
							 Upon failire, a task is re-executed up to 'retry' times. 
							 I.e. a task is considered failed only after failing 'retry + 1' times.
						</td>
					</tr>
					<tr>
						<td> system </td>
						<td> Default system type. If unspecified, the default system is 'local' (run tasks on local computer) </td>
					</tr>
					<tr>
						<td> timeout  </td>
						<td> Task timeout in seconds (default is one day)  </td>
					</tr>
					<tr>
						<td> walltimeout  </td>
						<td> Task's wall-timeout in seconds (default is one day). 
							 Wall timeout includes all the time that the task is waiting to be executed. 
							 I.e. the total amount of time we are willing to wait for a task to finish.
							 For example if walltimeout is one day and a task is queued by the cluster 
							 system for one day (and never executed), it will timeout, even if the task 
							 was never run.
						</td>
					</tr>
					<tr>
						<td> taskShell </td>
						<td> Shell to be used when running a <code>task</code> (default '/bin/sh -e')<br>
							 <b>WARNING</b>: Make sure you use "-e" or some command line option that stops execution when an error if found.
						</td>
					</tr>
					<tr>
						<td> sysShell  </td>
						<td> Shell to be used when running a <code>sys</code> (default '/bin/sh -e -c')<br>
							 <b>WARNING</b>: Make sure you use "-e" or some command line option that stops execution when an error if found.<br>
							 <b>WARNING</b>: Make sure you use "-c" or some command line option that allows providing a script
						</td>
					</tr>
				</table>

				<br>
				<h3>Cluster options </h3>
				This section defines parameters to customize <code>bds</code> to run tasks on your cluster.

				<table class="table table-striped">
					<tr>
						<th>Parameter</th>
						<th> Comments / examples </th>
					</tr>
					<tr>
						<td> pidRegex </td>
						<td> 
							Regex used to extract PID from cluster command (e.g. qsub). 
							<br>
							<br>
							When <code>bds</code> dispatches a task to the cluster management system (e.g. running 'qsub' command), it expects the cluster system to inform the jobID.
							Typically cluster systems show jobIDs in the first output line.
							This regex is used to match that jobID.
							<br>
							<br>
							Default, use the whole line<br>
							Note: Some clusters add the domain name to the ID and 
      							then never use it again, some other clusters add 
      							a message (e.g. 'You job ...')
							<br>
							<br>
							Examples:
<pre>
pidRegex = "(.+).domain.com"
pidRegex = "Your job (\\S+)"
</pre>

						</td>
					</tr>
					<tr>
						<td> clusterRunAdditionalArgs </td>
						<td>
							These command line arguments are added to every cluster 'run' command (e.g. 'qsub')<br>
							The string is split into spaces (regex: '\s+') and added to the cluster's run command.<br>
							<br>
							For instance the following configuration:<br>
							<br>
							<pre> clusterRunAdditionalArgs = -A accountID -M user@gmail.com </pre>
							will cause four additional arguments <code>{ '-A', 'accountID', '-M', 'user@gmail.com' }</code> to 
							be added immediately after 'qsub' (or similar) command used to run tasks on a cluster.
						</td>
					</tr>
					<tr>
						<td>clusterKillAdditionalArgs</td>
						<td>
						These command line arguments are added to every cluster 'kill' command (e.g. 'qdel')<br>
						Same rules as 'clusterRunAdditionalArgs' apply
						</td>
					</tr>
					<tr>
						<td>clusterStatAdditionalArgs</td>
						<td>
						These command line arguments are added to every cluster 'stat' command (e.g. 'qstat')<br>
						Same rules as 'clusterRunAdditionalArgs' apply
						</td>
					</tr>
					<tr>
						<td>clusterPostMortemInfoAdditionalArgs</td>
						<td>
						These command line arguments are added to every cluster 'post mortem info' command (e.g. 'qstat -f')
						Same rules as 'clusterRunAdditionalArgs' apply
						</td>
					</tr>
				</table>

				<br>
				<h3>SGE Cluster options </h3>
				This section defines parameters to customize <code>bds</code> to run tasks on a Sun Grid Engine cluster.
				<br>
				<br>

				<b>IMPORTANT:</b>	In SGE clusters it is important to enable <code>ENABLE_ADDGRP_KILL=true</code> to the <code>execd_params</code> parameter of <code>qconf -sconf</code>.
									Otherwise SGE might not be able to kill <code>bds</code> subprocesses running on slave nodes if this option is not enabled.
									So, if you don't activate <code>ENABLE_ADDGRP_KILL=true</code> killing processes may not work in SGE clusters, nodes will continue to run tasks even after they've been killed either Ctrl-C to bds or by a direct <code>qdel</code> command (the cluster reports them as finished, but they might still be running in the slave node).
				<br>
				<br>

				<table class="table table-striped">
					<tr>
						<th>Parameter</th>
						<th> Comments / examples </th>
					</tr>
					<tr>
						<td> sge.pe </td>
						<td>
						Parallel environment in SGE (e.g. 'qsub -pe mpi 4')<br>
						<br>
						Note on SGE's parallel environment ('-pe'):<br>
						<br>
						  The defaults were set to be compatible with <b>StarCluster</b>.<br>
						  Parallel environment defines how 'slots' (number of cpus requested) 
						  are allocated. <b>StarCluster</b> by default sets up a parallel environment, called “orte”, 
						  that has been configured for OpenMPI integration within SGE and has a number of slots 
						  equal to the total number of processors in the cluster.<br>
						  See details <code>qconf -sp orte</code>:<br>
<pre>
pe_name            orte
slots              16
user_lists         NONE
xuser_lists        NONE
start_proc_args    /bin/true
stop_proc_args     /bin/true
allocation_rule    $round_robin
control_slaves     TRUE
job_is_first_task  FALSE
urgency_slots      min
accounting_summary FALSE
</pre>
						<br>
						  Notice the <code>allocation_rule = $round_robin</code>.  This defines how to assign slots to a job. By 
						  default StarCluster configures round_robin allocation. This means that if a job requests 8 
						  slots for example, it will go to the first machine, grab a single slot if available, move to 
						  the next machine and grab a single slot if available, and so on wrapping around the cluster 
						  again if necessary to allocate 8 slots to the job.
						<br>
						  You can also configure the parallel environment to try and localize slots as much as 
						  possible using the "fill_up" allocation rule and job_is_first_task of TRUE.
						<br>
						  To configure: qconf -mp orte
</td>
					</tr>
					<tr>
						<td> sge.mem </td>
						<td> Parameter for requesting amount of memory in qsub (e.g. <code>qsub -l mem 4G</code>) </td>
					</tr>
					<tr>
						<td> sge.timeout </td>
						<td> Parameter for timeout in qsub (e.g. <code>qsub -l h_rt 24:00:00</code>) </td>
					</tr>
				</table>
				<br>

				<h3>Generic Cluster options </h3>
				Cluster <b>generic</b> invokes user defined scripts for manupulating tasks.
				This allows the user to customize scripts for particular cluster environments (e.g. environments not currently supported by <code>bds</code>)
				<br>
				<br>
				<b>Note</b>: You should either provide the script's full path or the scripts should 
					  be in your PATH
				<br>
				<br>
				<b>Note</b>: These scripts "communicate" with bds by printing information on STDOUT. The 
					  information has to be printed in a very specific format. Failing to adhere 
					  to the format will cause bds to fail in unexpected ways.
				<br>
				<br>
				<b>Note</b>: You can use command path starting with '~' to indicate <code>$HOME</code> dir or '.' to 
					  indicate path relative to config file's dir
				<br>
				<br>
				<table class="table table-striped">
					<tr>
						<th>Parameter</th>
						<th> Comments / examples </th>
					</tr>
					<tr>
						<td> clusterGenericRun </td>
						<td>
							The specified script is executed when a task is submitted to the cluster
							<br>
							<br>
							<b>Script's expected output</b>:
								The script MUST print the cluster's jobID AS THE FIRST LINE. 
								Make sure to flush STDOUT to avoid other lines to be printed out of order.
							<br>
							<br>
							<b>Command line arguments</b>:
								<ol>
									<li> Task's timeout in seconds. Negative number means 'unlimited' (i.e. let the cluster system decide)
									<li> Task's required CPUs: number of cores within the same node.
									<li> Task's required memory in bytes. Negative means 'unspecified' (i.e. let the cluster system decide)
									<li> Cluster's queue name. Empty means "use cluster's default"
									<li> Cluster's STDOUT redirect file. This is where the cluster should redirect STDOUT.
									<li> Cluster's STDERR redirect file. This is where the cluster should redirect STDERR
									<li> Cluster command and arguments to be executed (typically is a "bds -exec ...").
								</ol>
							<br>
							<br>
							<b>Example:</b> For examples on how to build this script, take a look at <code>config/clusterGeneric*</code> directory in the source code.
						</td>
					</tr>
					<tr>
						<td> clusterGenericKill  </td>
						<td>
							The specified script is executed in order to kill a task
							<br>
							<br>
							<b>Script's expected output</b>:
								None
							<br>
							<br>
							<b>Command line arguments</b>:
								jobId: This is the jobId returned as the first line in 'clusterGenericRun' 
									  script (i.e. the jobID provided by the cluster management system)
							<br>
							<br>
							<b>Example:</b> For examples on how to build this script, take a look at <code>config/clusterGeneric*</code> directory in the source code.
						</td>
					</tr>
					<tr>
						<td> clusterGenericStat </td>
						<td>
							The specified script is executed in order to show the jobID of all jobs currently scheduled in the cluster
							<br>
							<br>
							<b>Script's expected output</b>:
								This script is expected to print all jobs currently scheduled or 
								running in the cluster (e.g. qstat), one per line. The FIRST column 
								should be the jobID (columns are space or tab separated). Other 
								columns may exist (but are currently ignored).
							<br>
							<br>
							<b>Command line arguments</b>:
								None
							<br>
							<br>
							<b>Example:</b> For examples on how to build this script, take a look at <code>config/clusterGeneric*</code> directory in the source code.
						</td>
					</tr>
					<tr>
						<td> clusterGenericPostMortemInfo  </td>
						<td>
							The specified script is executed in order to get information of a recently 
							finished jobId. This information is typically used for debuging and is added to bds's output.
							<br>
							<br>
							<b>Script's expected output</b>:
								The output is not parsed, it is stored and later shown 
								in bds's report. Is should contain information relevant 
								to the job's execution (e.g. <code>qstat -f $jobId</code> or <code>checkjob -v $jobId</code>)
							<br>
							<br>
							<b>Command line arguments</b>:
								jobId: This is the jobId returned as the first line in 'clusterGenericRun' 
								script (i.e. the jobID provided by the cluster management system)
							<br>
							<br>
							<b>Example:</b> For examples on how to build this script, take a look at <code>config/clusterGeneric*</code> directory in the source code.
						</td>
					</tr>
				</table>

				<h3>SSH Cluster options </h3>
				Cluster <b>shh</b> creates a virtual cluster using several nodes access via shh.
				<br>
				<br>
				<br>
				<table class="table table-striped">
					<tr>
						<th>Parameter</th>
						<th> Comments / examples </th>
					</tr>
					<tr>
						<td> ssh.nodes </td>
						<td> 
							This defines the userName and nodes to be accessed via ssh.
							<br>
							<br>
							Examples:
							<br>
							<ul>
								<li> A trivial 'ssh' cluster composed only of the localhost accesed via ssh (useful for debugging)
<pre>
ssh.nodes = user@localhost
</pre>
								<li> Some company's servers used as an ssh cluster
<pre>
ssh.nodes = user@lab1-1company.com, user@lab1-2company.com, user@lab1-3company.com, user@lab1-4company.com, user@lab1-5company.com
</pre>
								<li> A StarCluster run on Amazon AWS
<pre>
ssh.nodes = sgeadmin@node001, sgeadmin@node002, sgeadmin@node003, sgeadmin@node004, sgeadmin@node005, sgeadmin@node006
</pre>
							</ul>
						</td>
				</table>
			</div>
		</div>

		<!-- Docs nav
		================================================== -->
		<div class="col-md-3">
			<div class="bs-docs-sidebar hidden-print hidden-xs hidden-sm" role="complementary" data-spy="affix">
				<ul class="nav bs-docs-sidenav" data-spy="affix">
					<li><a href="#install"> Download &amp; Install</a></li>
					<li><a href="#intro"> Introduction</a></li>
					<li><a href="#hello"> Hello world </a></li>
					<li><a href="#language"> Language </a>
						<ul class="nav">
							<li><a href="#language-special"> Special pourpose </a></li>
							<li><a href="#language-type"> Data types </a></li>
							<li><a href="#language-string"> String </a></li>
							<li><a href="#language-array"> Array </a></li>
							<li><a href="#language-map"> Map </a></li>
							<li><a href="#vars"> Predefined variables </a></li>
						</ul>
					</li>

					<li><a href="#task"> Creating data pipelines </a>
						<ul class="nav">
							<li><a href="#task-depend"> Task dependencies</a></li>
							<li><a href="#task-wait"> Wait </a></li>
							<li><a href="#task-depop"> Dependency operator </a></li>
							<li><a href="#task-autodep"> Automatic dependency </a></li>
							<li><a href="#task-goal"> 'dep' and 'goal' </a></li>
						</ul>
					</li>

					<li><a href="#sys"> Sys </a></li>
					<li><a href="#taskExpr"> Task </a></li>
					<li><a href="#waitExpr"> Wait </a></li>
					<li><a href="#dep"> Dependency operator </a></li>
					<li><a href="#goal"> Goals </a></li>
					<li><a href="#remote"> Remote files </a></li>
					<li><a href="#par"> Parallel execution </a></li>
					<li><a href="#check"> Checkpoints </a></li>

					<li><a href="#test"> Test cases </a></li>
					<li><a href="#debugger"> Debugger (built in) </a></li>
					<li><a href="#cmdLineParse"> Command line parsing </a></li>
					<li><a href="#autoHelp"> Automatic help</a></li>
					<li><a href="#autoLog"> Logging </a></li>
					<li><a href="#cleanup"> Cleanup </a></li>

					<li><a href="#commandLine"> BDS command line </a></li>
					<li><a href="#config"> BDS config file </a></li>
				</ul>
			</div>
		</div>
	
	</div>
</div>

<footer> <p class="text-center"><a class="body" href="http://www.linkedin.com/in/pablocingolani">Created by Pablo Cingolani</a></p> </footer>

<!-- Placed at the end of the document so the pages load faster -->
<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
</body>
</html>
